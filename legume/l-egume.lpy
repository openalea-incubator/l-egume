import sys
import os

try:
    import legume
    path_ = os.path.dirname(os.path.abspath(legume.__file__))#local absolute path of L-egume
except:
    path_ = r'C:\devel\l-egume\legume'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\luzerne' #r'C:\devel\grassland'#
path_leg = os.path.join(path_, 'input')#r'C:\devel\l-egume\l-egume\input'#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'
path_out = os.path.join(path_, 'output')#r'C:\devel\grassland'#r'H:\devel\grassland\grassland\L-gume' #r'C:\devel\grassland'

sys.path.insert(0, path_)
sys.path.insert(0, path_leg)


from rpy_options import set_options
set_options(RHOME='c:/progra~1/R/R-2.12.1')
from rpy import r
r.source(os.path.join(path_, 'dist_tetaf.r'))#'dist_tetaf.r') #r.source('C:/devel/grassland/dist_tetaf.r') #in L-egume folder
r.source(os.path.join(path_, 'calc_root_tropism.r'))#r.source('C:/devel/grassland/calc_root_tropism.r') #in L-egume folder
#r.source('dist_tetaf.r') #in L-gume folder
#r.source('calc_root_tropism.r') #in L-gume folder




from numpy.random import binomial, seed
from scipy import * 
from copy import deepcopy
import string
import time
from openalea.plantgl.all import *
from Obj3Dutils import *
import soil_moduleN3 as solN #soil_moduleN2_bis as solN #! renommer car dans nouvelle version Lpy, mot module est reserve et fait planter!
import RIRI5 as riri
import RootDistrib as rtd
import RootMorpho2 as rt
import IOtable
import IOxls
import random


## lecture fichier meteo
#faire une fonction??
meteo_path = os.path.join(path_leg,'meteo_exemple_debugL_gl.xls')#r'H:\devel\grassland\grassland\L-gume\meteo_exemple2.xls'
ongletM = 'Lusignan302ans'#'Lusignan30'#'DivLeg15'#'morpholeg15'#'combileg15'#'combileg16'#'Avignon30'#'exemple'#'morpholeg15'#'testJLD'#'competiluz'#
meteo = IOxls.read_met_file(meteo_path, ongletM)

## lecture fichier management
mn_path = os.path.join(path_leg,'management_exemple3_debugL_gl.xls')#r'H:\devel\grassland\grassland\L-gume\management_exemple.xls'
ongletMn = 'Lusignan30IrrN2ans'#'Lusignan30IrrN'#'DivLeg15'#'Lusignan30IrrN'#'illimite-sanscoupe'#'combileg15-irrigajusteeLUZTVMIN'#'combileg16-irrigajusteeMIN'#'Lusignan30'#'Avignon30IrrN'#'Avignon30'#
mng = IOxls.read_met_file(mn_path, ongletMn)

## lecture fichier initialisation
inis_path = os.path.join(path_leg,'Initialisation_sol_exemple.xls')
ongletIn = 'Lusignan30_5x5'#'Lusignan30'#'morpholeg_rhizo'#'combileg15'#'combileg16'#'Lusignan30Irr'#'Avignon30IrrN'#'Avignon30'#'
inis = IOxls.read_plant_param(inis_path, ongletIn)


## lecture fichier plante
path_plante = os.path.join(path_leg,'Parametres_plante_v5cLucas.xls')#'Parametres_plante_v18.xls')#'Parametres_plante_v9Lucas_debugL.xls')#r'H:\devel\grassland\grassland\L-gume\Parametres_plante_v5cLucas.xls' 
ongletP = 'Fix1'#'Fix'#'timbale'#'formica'#'canto'#'giga'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
ongletPvois = 'nonFix1'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#

#lecture des parametres du sol
path_sol = os.path.join(path_leg,'Parametres_sol_exemple2_debugL_glbis.xls')#
ongletS = 'lusignan99'#'morpholeg'#'combileg2015vshallow'#'combileg16vshallow'#'ASCHYD11'#
par_SN, par_sol = IOxls.read_sol_param(path_sol, ongletS)
par_SN['concrr'] = 0.#force eau de pluie / irrig a zero N, sinon apport 300 kg en irrigue!

#lecture scenario (si changement de parametres)
mn_sc = os.path.join(path_leg,'liste_scenarios.xls')#(path_leg,'liste_scenarios.xls')
ongletScenar1 = 'default'#
ongletScenar2 = 'nonFix1'#'default'




#chemin des fichiers de sortie (doivent etre declares avant de lancer le L-system, pour pouvoir l'appeller en dehors de L-py)
outvarfile = 'toto.csv'#r'H:\devel\grassland\grassland\L-gume\toto.csv'
lsorgfile = 'lsAxes.csv'#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
outimagefile = 'scene.bmp'#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
outHRfile = 'outHR.csv'#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
outBilanNfile = 'BilanN.csv'#r'H:\devel\grassland\grassland\L-gume\BilanN.csv'
resrootfile = 'newres.csv'#r'H:\devel\grassland\newres.csv'



#initialisation des variables globale de simulation
DOYdeb = 60#49#159#124#
DOYend = 610#335#120#250#244#282#
Rseed = 0#2#0 #random seed
deltalevmoy = 30 #degre.jours
deltalevsd = 15

nbcote = 8#1#10
optdamier = 4
typearrangement='damier8'#'homogeneous'
idscenar1 = -1 #inferieur a zero=defaut et fait rien
idscenar2 = 10#-1 #inferieur a zero=defaut et fait rien
opt_sky = 'V'#'VXpXmYpYm'

cote = 40.#100.#100#25.#25.#cm
dz_aerien = 2.#2.#2.5#5.#7.5#10.#7.#cm dz vise
Hmaxcouv = 150.#150.# 200. #cm
latitude = 46.43 #Lusignan (degre) -> a passer dans le fichier inis

obstarac_ = None#array([[-0.5]*5, [-0.5]*5, [-0.75]*5, [-1.]*5, [-1.]*5]).transpose() #matice 2D de valeurs de profondeur d'obstacle en m #None #



#1 residu = listes de 1 element
#DOYres = DOYdeb+20#300 #jour d'ajout des residus -> pas utilise
nb_res = 8

vAmount= [0.1]*nb_res#[20.]# T Fresh Weight.ha-1 (equivalent QRES)
vCNRESt = [16.]*4+[40.]*4 #g.g-1 (equivalent CsurNres)
Vprop1 = [1./3., 1./3., 1./3.]+27*[0.] #distribution dans les horizons
vProps= [Vprop1]*nb_res#[Vprop1]#[Vprop1, Vprop1, Vprop1]
vWC=[0.7]*nb_res# fraction d'eau des residu frais (equivalent de Crespc /(%)/100)
vCC=[0.42]*nb_res# fraction de C des residus sec (equivalent de Crespc /(%)/100)
vNmires = [0.00197]*nb_res# fraction de poids frais residu en azote mineral (equivalent de Nminres(%)/100)



#options de simation
opt_residu = 1 #si 0, pas ativation de mineralisation
visu_root=1#1# pour visualisation/interpretation root
visu_shoot=1#1# pour visualisation/interpretation shoot
visu_sol=1#1# pour visualisation/interpretation sol
#550 it en 2013s/1940s
#curieusement plante (memory error??) quand pas de visualisation??-> a creuser
# plante pas si visu_shoot a 1...
#essai avec modif des test: OK, mais pad de gain de temps 




def init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd):
    
    ## meteo du jour
    DOY=DOYdeb
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','I0','Et0','Precip','Tsol'], 'DOY', val=DOY)
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    for k in meteo_j.keys(): meteo_j[k]=meteo_j[k][0]
    for k in mng_j.keys(): mng_j[k]=mng_j[k][0]
    
    
    TT = 0
    TTsol = 0
    STEPS_ = meteo_j['TmoyDay']-5.#dTT(meteo_j['TmoyDay'], [ParamP[0]['Tdev']])# #variable remise  ajour chaque jour
    STEPSsol_ = meteo_j['Tsol']-5.
    ls_epsi = [0.]# [0.4, 0.4]##!! correspondance avec les nb de root systems!
    
    
    ##coupe
    TT_repousse = 0 #TT de la derniere coupev #resoud pb: TT utilise pour LAI pour NI revenait jamais a zero
    isTTcut = False
    #TTcutFreq = 18.*32#15.*32 #phyllochron
    isRegrowth = False #indicateur: est on a la pousse initiale ou bien plus tard?
    Hcut = 1.#3.#simple initialisation : est passe en lecture fichier management
    cutNB = 0
    
    ## divers
    start_time, past_time= time.time(), 0. #pour recuperer temps de calcul
    
    #distribution des retard a levee
    #deltalevmoy = 30 #degre.jours
    #deltalevsd = 15
    test_retard = []#pour gerer un decalage a la levee/reprise
    
    for i in range(138): test_retard.append(max(0,random.gauss(deltalevmoy,deltalevsd)))#test_retard.append(random.uniform(0,60))
    #for i in range(138): test_retard.append(0)#pas de retard.
    # a affectr a ['TT']!!
    
    return DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard 





def damier8(p,vois,opt=4):
    #cree un melange binaire homogene de 64 plantes avec differentes options de proportions
    if opt==4:#50/50
        motif = [p,vois,p,vois,p,vois,p,vois]
    elif opt==0:#0/100
        motif = [vois,vois,vois,vois,vois,vois,vois,vois]
    elif opt==8:#100/0
        motif = [p,p,p,p,p,p,p,p]
    elif opt==2:#25/75
        motif = [p,vois,vois,vois,p,vois,vois,vois]
    elif opt==6:#75/25
        motif = [vois,p,p,p,vois,p,p,p]
    elif opt==1:#1/8
        motif = [p,vois,vois,vois,vois,vois,vois,vois]
    elif opt==7:#7/8
        motif = [vois,p,p,p,p,p,p,p]
    
    res = []
    for i in range(8):
        res = res+motif[i:8]+motif[0:i]
        
    return res


def modif_param(gx, ongletP, ongletScenar, idscenar, idlist=1):
    """ fait rien si ongletScenar='default' ou iscenar<0 ou onglet correspond pas a celui a modifier; sinon va modifier selon fichier scenario"""
    if ongletP == ongletScenar and idscenar>0: #si onglet correspond a ongletscenat a modifier
        usc = IOxls.xlrd.open_workbook(mn_sc)
        ls_sc = IOtable.conv_dataframe(IOxls.get_xls_col(usc.sheet_by_name(ongletScenar)))
        nb_modif = len(ls_sc.keys())-1 #nb de param a modifier
        ls_sc['id_scenario'] = map(int,ls_sc['id_scenario'])
        
        if nb_modif>0:#s'il y a des parametre a modifier
            idok = ls_sc['id_scenario'].index(idscenar)
            keys_modif = ls_sc.keys()
            keys_modif.remove('id_scenario')
            for k in keys_modif:
                if str(ls_sc[k][idok]) != '' or str(ls_sc[k][idok]) != 'NA': #y a un valeur specifiee
                    if type(gx[k]) == type(0.): #gere uniquement les parametres avec 1 seule valeur float (pas liste)
                        gx[k] = ls_sc[k][idok]
                    elif type(gx[k]) == list: #pour les liste, gere uniquement un id de la liste (1 par defaut)
                        gx[k][idlist] == ls_sc[k][idok]
    return gx


def init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type='homogeneous', opt=4, ongletScenar1='default', ongletScenar2='default',idscenar1=1, idscenar2=1):
    
    #1) cree liste des paramtres plante (1dico par plante)
    #nbcote = nombre de plante sur un cote en supposant repartition homogene
    g4 = IOxls.read_plant_param(path_plante, ongletP)
    g4 = modif_param(g4, ongletP, ongletScenar1, idscenar1)
    g5 = IOxls.read_plant_param(path_plante, ongletPvois)
    g5 =  modif_param(g5, ongletPvois, ongletScenar2, idscenar2)
    if type == 'homogeneous': #cas d'un couvert monospe homogene
        ParamP = [g4]*nbcote*nbcote
    elif type == 'damier8':#damier binaire 64 plantes
        ParamP = damier8(g4,g5,opt=opt)
    else:#defautl= force nb plante comme nbcote
        ParamP = [g4]*nbcote
        #ParamP = [g4]*10#*2#*30#[g6, g4, g6, g4, g6, g4, g6]#[g6,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4,g4]#[g4] 
        #[g1, g2, g3]#[g4, g5, g5, g5, g5, g5, g5] 
    
    
    #2) ajout de parametre 'recalcule'
    for nump in range(len(ParamP)):
      #update des parametre racinaire
      rt.update_root_params(ParamP[nump]) #'lsDrac', 'nb_ordre_rac', 'lsVrac', 'lsDemanDRac', 'LDs'
      #print 'LDs', ParamP[nump]['LDs2'], ParamP[nump]['LDs3'], ParamP[nump]['lsDrac'], ParamP[nump]['GDs2'], ParamP[nump]['GDs3']
      
      cor_lF = sqrt(ParamP[nump]['leafshape']/0.5) #pour afficher feuille avec surface reelle et corriger effet losange
      cor_lstp = sqrt(ParamP[nump]['stipshape']/0.5) #pour afficher feuille avec surface reelle et corriger effet losange
      
      ParamP[nump]['profilLeafI_l'] = []
      ParamP[nump]['profilLeafI_larg'] = []
      ParamP[nump]['profilNodeI_l'] = []
      ParamP[nump]['profilPetI_l'] = []
      ParamP[nump]['profilStipI_l'] = []
      ParamP[nump]['profilStipI_larg'] = []
      ParamP[nump]['profilPetI_l'] = []
      ParamP[nump]['profilLeafI_nfol'] = []
      ParamP[nump]['k_teta_distf'] = r.disttetaf(abs(ParamP[nump]['gammaFeuil']), ParamP[nump]['gammaFeuilSD']) #proportion de feuille par        classe d'incli pour calcul des k_teta
      
      ParamP[nump]['profilRoot'] = r.rootTropism(ParamP[nump]['IncRoot0'], ParamP[nump]['g_root'], segment=0.3, Long=300.)#trajet d'une racine fille II
      
      for rank in range(1,51): #!limite a 50 noeuds!
          Norml_leaf = min(ParamP[nump]['profilLeafI_Rlen'][0]*rank+ParamP[nump]['profilLeafI_Rlen'][1], ParamP[nump]['profilLeafI_Rlen'][2]*rank+ParamP[nump]['profilLeafI_Rlen'][3])
          Normlarg_leaf = max(ParamP[nump]['profilLeafI_Rlarg'][0]*rank+ParamP[nump]['profilLeafI_Rlarg'][1], ParamP[nump]['profilLeafI_Rlarg'][2]*rank+ParamP[nump]['profilLeafI_Rlarg'][3])
          Norml_In = min(ParamP[nump]['profilNodeI'][0]*rank+ParamP[nump]['profilNodeI'][1], ParamP[nump]['profilNodeI'][2]*rank+ParamP[nump]['profilNodeI'][3])
          Norm_pet = min(ParamP[nump]['profilPetI'][0]*rank+ParamP[nump]['profilPetI'][1], ParamP[nump]['profilPetI'][2]*rank+ParamP[nump]['profilPetI'][3])
          Norml_Stp = min(ParamP[nump]['profilStpI_l'][0]*rank+ParamP[nump]['profilStpI_l'][1], ParamP[nump]['profilStpI_l'][2]*rank+ParamP[nump]['profilStpI_l'][3])
          Normlarg_Stp = min(ParamP[nump]['profilStpI_Rlarg'][0]*rank+ParamP[nump]['profilStpI_Rlarg'][1],ParamP[nump]['profilStpI_Rlarg'][2]*rank+ParamP[nump]['profilStpI_Rlarg'][3])
          Normnfol = min(ParamP[nump]['profilLeafI_Rnfol'][0]*rank+ParamP[nump]['profilLeafI_Rnfol'][1], 1.)#nfol est le maximum number of folioles
          
          ParamP[nump]['profilLeafI_l'].append(max(0.001,Norml_leaf*cor_lF*ParamP[nump]['Lfeuille']))
          ParamP[nump]['profilLeafI_larg'].append(max(0.001,Normlarg_leaf*Norml_leaf*cor_lF*ParamP[nump]['Lfeuille']))
          ParamP[nump]['profilNodeI_l'].append(max(0.001,Norml_In*ParamP[nump]['Len']))
          ParamP[nump]['profilPetI_l'].append(max(0.001,Norm_pet*ParamP[nump]['Lpet']))
          ParamP[nump]['profilStipI_l'].append(max(0.001,Norml_Stp*cor_lstp*ParamP[nump]['Lstip']))
          ParamP[nump]['profilStipI_larg'].append(max(0.001,Normlarg_Stp*Norml_Stp*cor_lstp*ParamP[nump]['Lstip']))
          ParamP[nump]['profilLeafI_nfol'].append(int(max(1,Normnfol*ParamP[nump]['nfol'])))#max 1 pour interdire les feuilles sans folioles.
    
    nbplantes = len(ParamP)
    return ParamP, nbplantes




def init_scene(ParamP, inis, cote, nbcote, dz_aerien, Hmaxcouv):
    #initialoise la scene: arrangement des plantes (carto), discretisation souterraine, discretisation aerienne
    # 1) CARTO
    distplantes = cote/nbcote#1. #cm
    
    ## pour ilot
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.])]#, array([-10.,0.,0.]), array([0.,7.,0.])] #liste des localisations (1pt par plante) -> a lire en fichier #LF - cos (pi/3) = 0.5   sin (pi/3) = 0.866
    
    #carto = [array([0.,0.,0.]), array([distplantes,0.,0.]),array([-distplantes,0.,0.]),array([0.5*distplantes,0.866*distplantes,0.]),array([-0.5*distplantes,0.866*distplantes,0.]), array([0.5*distplantes,-0.866*distplantes,0.]), array([-0.5*distplantes,-0.866*distplantes,0.]),array([2*distplantes,0.,0.]),array([-2*distplantes,0.,0.]),array([2*0.5*distplantes,2*0.866*distplantes,0.]),array([-2*0.5*distplantes,2*0.866*distplantes,0.]), array([2*0.5*distplantes,-2*0.866*distplantes,0.]), array([-2*0.5*distplantes,-2*0.866*distplantes,0.])] #carto13
    
    ## pour champ en rangs 
    #yyy = [-15]*9+[0]*9+[15]*9
    #xxx = range(-20,25,5)*3
    #yyy = [-15]*9+[-7.5]*9+[0]*9+[7.5]*9+[15]*9+[22.49]*9
    #xxx = range(-20,25,5)*6
    #yyy = [-15]*5+[0]*5+[15]*5
    #xxx = range(-20,25,10)*3
    #yyy = [-15]*2+[0]*2+[15]*2
    #xxx = range(-20,25,25)*3
    #yyy = [-15]*1+[0]*1+[15]*1
    #xxx = range(-20,25,60)*3
    #yyy = [-15]*23+[-7.5]*23+[0]*23+[7.5]*23+[15]*23+[22.49]*23
    #xxx = range(-20,25,2)*6
    
    #pour grand rhizotron
    #yyy = [-12.25, 4.4, 21.05]
    #xxx = [-10.75, -8.35, -5.95, -3.55, -1.15, 1.25, 3.65, 6.05, 8.45, 10.85]
    
    
    #pour carre distance homogene
    yyy = [distplantes/2.]
    for i in range(1,nbcote):yyy.append(yyy[-1]+distplantes)
    xxx = yyy
    
    carto = []
    for i in range(len(xxx)): 
        for j in range(len(yyy)):
            carto.append(array([xxx[i],yyy[j],0.]))
    
    
    # 2) definition du pattern et discretisation sol
    pattern8 = [[0,0], [cote,cote]]
    #pattern8 =[[min(xxx)-dp,min(yyy)-dp], [max(xxx)+dp,max(yyy)+dp]]
    #[[-2.5,-2.5], [2.5,2.5]]#[[-5.,-5.],[5.,5.]]#[[-2.5,-2.5], [5,5]]#[[-12.5,-12.5],[12.5,12.5]]
    #pattern8 = [[-22.3/2.,-49.5/2.], [22.3/2.,49.5/2.]]#pattern.8 rhizotron equivalent (cm)
    
    Lsol = max((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    largsol = min((pattern8[1][0]-pattern8[0][0])/100., (pattern8[1][1]-pattern8[0][1])/100.)#m
    surfsolref = Lsol*largsol #m2
    dz_sol = inis['dz_sol']#4.#5. #cm
    ncouches_sol = int(inis['ncouches_sol'])#4#10#30
    prof_sol_max = ncouches_sol*dz_sol#80.
    
    discret_solXY = map(int, inis['discret_solXY'])#[10,10]# nb de discretisation du sol en X et en Y
    lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol])
    
    
    #3) discretisation au niveau aerien
    #creation des grid3D pour calcul de rayonnement
    ls_gammagroup = map(int, riri.get_lsparami(ParamP, 'gammagroup'))
    setp = list(set(ls_gammagroup)) #set equivalent fonction r.unique!
    n_gamagroup = len(setp)
    
    for nump in range(len(ParamP)):#ajout a chaque plante de son id grille dans ParamP
        ParamP[nump]['id_grid'] = setp.index(int(ParamP[nump]['gammagroup']))  #pour savoir id de grille de la plante
    
    na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, dz_aerien, Hmaxcouv,opt='3D')
    #na, dxyz, lims_aer, origin_grid, surf_refVOX = riri.def_na_lims(pattern8, dz_aerien, Hmaxcouv,opt='1D') #version 1D, comme avant
    m_lais = zeros([n_gamagroup, na[2], na[1], na[0]]) #ngamma, Z,Y,,X
    m_lais_construct = deepcopy(m_lais) #pour contsruction du m_lais a t+1
    triplets = riri.get_ls_triplets(m_lais[0], opt=opt_sky)#'VXpXmYpYm')#opt='V')#
    
    #liste des k_teta (coeff extinction directionnels) par entite
    ls_dif = [] 
    #prepa des k_teta par entite
    for i in setp:
        nump = ls_gammagroup.index(i) #retrouve numero de plante de premiere occurence de gammagroup
        ls_dif.append(ParamP[nump]['k_teta_distf'])
    
    res_trans, res_abs_i = [],[]
    res_rfr = []
    
    
    return carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr
    #par logique, passer cote et nbcote dans ini?





def init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol,obstarac =None):
    
    #vecteurs d'initialisation du sol
    Tsol = meteo_j['Tsol']#15. #degresC
    num_nb = map(int, inis['num_nb'])#[6,6,18] #nbr de couche de chaque num de sol 
    vsoilnumbers = [1]*num_nb[0]+[2]*num_nb[1]+[3]*num_nb[2] #convention autorise 3 types d'horizon max
    #vDA = [par_SN['DA'][0]]*num_nb[0] + [par_SN['DA'][1]]*num_nb[1] + [par_SN['DA'][2]]*num_nb[2] #densite apparente de sol
    vCN = [par_SN['CN0_30']]*num_nb[0] + [par_SN['CN30_60']]*num_nb[1] + [par_SN['CN60_90']]*num_nb[2] #maxi 3 horizons
    vMO = [par_SN['MO0_30']]*num_nb[0] + [par_SN['MO30_60']]*num_nb[1] + [par_SN['MO60_90']]*num_nb[2] #maxi 3 horizons
    vARGIs = [par_SN['ARGIs0_30']]*num_nb[0] + [par_SN['ARGIs30_60']]*num_nb[1] + [par_SN['ARGIs60_90']]*num_nb[2]
    vCALCs = [par_SN['CALCs']]*ncouches_sol
    vNH4 = inis['NH4']#[2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    vNO3 = inis['NO3']#[0.]*ncouches_sol
    HRpinit = inis['HRp']#[]
    if min(HRpinit)<0: #code -1 pour pas d'initialisation
        HRpinit = []
        
    vDA=[]
    for i in vsoilnumbers:
        vDA.append(par_sol[str(i)]['DA'])
        
    
    #vsoilnumbers = [1]+[2]*3+[3]*13+[4]*13 #numeros de sol du profil -> mesures acsyd11
    #vDA = [1.81]+[1.31]*3+[1.37]*13+[1.42]*13 #densite apparente de sol (mesure pesees initial aschyd11)
    #vCN = [par_SN['CN0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vMO = [par_SN['MO0_30']]*ncouches_sol #maxi 90cm en strates de 5cm
    #vARGIs = [par_SN['ARGIs']]*ncouches_sol #maxi 90cm
    #vCALCs = [par_SN['CALCs']]*ncouches_sol
    #vNH4 = [2.]*ncouches_sol # #!! kg d'N.ha-1 (entree de STICS)
    #coeff = 0.#0.09#coeff perte ressuyage -> a ajuster pour avoir environ 600 kg N.ha-1
    #vNO3 = [91.*coeff]*ncouches_sol # kg d'N.ha-1 (entree de STICS)
    #vNO3 = array([16.96, 16.07, 15.17, 33.92, 33.92, 33.92, 33.92, 62.49, 82.13, 89.27, 76.77, 107.13, 124.98, 142.84, 124.98, 142.84, 160.69, 151.76, 151.76, 142.84, 178.55, 133.91, 98.20, 89.27, 83.92, 89.27, 73.20, 89.27, 87.45, 62.49])*coeff #issu du profil en sol nu
    #HRpinit = [25.5,26.,25.,25.5,26.,26.,26.,26.5,26.5,27.,27.,27.,27.5,27.5,27.5,27.5,27.5,29,29,29,29,29,29,29,29,30,30,30,30,30]#-> mesures ahscyd au jour 195 (140711) -> init sol nu
    
    
    ## soil initialisation
    S = solN.SoilN(par_sol, par_SN, soil_number = vsoilnumbers, dxyz = [[Lsol/discret_solXY[0]]*discret_solXY[0], [largsol/discret_solXY[1]]*discret_solXY[1], [dz_sol/100.]*ncouches_sol], vDA=vDA, vCN=vCN,vMO=vMO, vARGIs = vARGIs,vNO3=vNO3,vNH4=vNH4, vCALCs=vCALCs, Tsol=Tsol,pH=par_SN['pH'], ZESX=par_SN['ZESX'] , CFES=par_SN['CFES'],obstarac=obstarac)
    
    
    if HRpinit!=[]:#initialise humidite si un vecteur est fourni
        S.init_asw(HRp_init=HRpinit) 
    
    
    #lims_sol = rtd.lims_soil(pattern8, dxyz=[[Lsol], [largsol], [dz_sol/100.]*ncouches_sol])
    
    if opt_residu==1:#initialisatio de residus
        S.init_residues(vCNRESt, vAmount, vProps, vWC, vCC)
    
    
    #print 'sol', sum(S.m_NO3), sum(S.m_NH4), sum(S.m_QH20fc)-sum(S.m_QH20wp)
    
    #Uval = 0.9*2.61#(epaisseur de sol* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    Uval = par_SN['q0']*0.1*sum(S.m_QH20fc[0])*surfsolref / (S.dxyz[2][0]*100.)#(epaisseur de sol (cm)* mm d'eau dans 1cm) #U quantite d'eau dans une couche superieure en mm (5 par default)
    stateEV = [0.,0.,0.] #pour le calcul de l'evaporation du sol (memoire du cumul evapore depuis derniere PI)
    b_= solN.bEV(par_SN['ACLIMc'], par_SN['ARGIs'], HXs=0.261)#1.#valeur empirique tres proche#0.1#0.63#0.63
    #!!!
    
    return S, Tsol, Uval, stateEV, b_





# a recup dans un module N exterieur
def Na_N0(I_I0):
    """ teneur en azote relative en fonction de fraction d'eclairement - Louarn et al. 2014 """
    return I_I0**0.247 

def N0(INN):
    """ teneur en azote des feuilles eclairees (g N.m-2) en fonction de INN - Louarn et al. 2014 """
    return 2.08*INN+0.05

def Nl_Nl0(I_I0):
    """ teneur en N lineique relative des tiges """
    Nresidu = 0.17
    return Nresidu + (1-Nresidu)*I_I0**0.51



def init_variables_plantes(ParamP, nbplantes):
    
    # 1) INVAR
    #dico des variables interne instantanes par plante  utilises dans differents calculs ou preparant des sorties
    
    ## SurfPlante: liste (par nump) de liste de surface de feuille verte au temps t 
    ## PARaPlante: liste (par nump) de liste de PARa feuille verte au temps t
    ## PARiPlante: liste (par nump) de liste de PARi feuille verte+senescente au temps t
    ## parap (anciens dpar / ls_parap): liste de delta de PARa du jour par plante (feuilles vertes) (utilise pour modulation racines notamment)
    ## parip: liste de delta de PARa du jour par plante (feuilles vertes+senescente)
    ## Hplante : liste de hauteur max des plantes
    ## Dplante: liste de diametre max des plantes
    ## Mrac_fine: Liste (par step/jour) de liste de delta de MSracines fines par plante
    ## Mpivot: Liste (par step/jour) de liste de delta de MSpivot par plante
    ## Maerien: Liste (par step/jour) de liste de delta de MSaerien par plante
    ## MS_rac_fine: liste des MSracines_fines cumule au temps t par plante
    ## MS_pivot: liste des MSpivot cumule au temps t par plante
    ## MS_aerien: liste des MSaerien cumule au temps t par plante
    ## MS_aer_cumul: liste des MSaerien cumule, SANS REMISE A ZERO A LA COUPE, pour calcul d'allocation aux racines.
    ## RLTot: liste de total fine root length par plante(m)
    ## Rdepth: liste de profondeur max du pivot par plante (cm)
    ## DiampivMax: liste de diametre max des pivot par plante
    ## countSh: Liste de nb tiges I cumule emis par plante depuis levee (tout A emis de B) - Compteur de Tige I
    ## countShExp: Liste de nb tiges I cumule emis par plante depuis levee par voie B->BDA - Compteur de bourgeons au niveau de la courrone  
    ## NBsh : Liste par plante de nb tiges (I ou II) avec nb phytomeres>50% du max
    ## NBI : Liste par plante de nombre de phytomere maxi sur tiges I ayant >75% du max
    ## NBD1 : Liste par plante de nombre de bourgeons dormants D()
    ## NBB : Liste par plante de nombre de bourgeons actifs B()
    ## NBBexp : Liste par plante de nombre de bourgeons actifs B() de statut exp = generateur de nouveaux axes
    ## lsA : Liste par plante de numero de nsh (B() et A()) actifs ou non
    ## lsAPrev : Liste par plante de numero de nsh (B() et A()) actifs ou non au step n-1 : utilise pour maintenir en dormance les D()
    ## lsApexMort : Liste par plante de numero de nsh (A()) mort
    ## DemandN_Feuil : Liste par plante de quantite d'N des feuille pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Pet : Liste par plante de quantite d'N des petioles pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Stem : Liste par plante de quantite d'N des tiges pour satisfaire 1 INN = 1 (g.plant-1)
    ## DemandN_Tot : Liste par plante de quantite d'N totales pour satisfaire 1 INN = 1 (g.plant-1)
    ## R_DemandC_Root : Liste par plante de ratio offre/demande C pour croissance des racines
    ## RLen1, Len2,RLen3,RLen4,RLentot : Liste par plante de longueur cumulee de racine d'ordre 1, 2, 3 et total (m)
    ## SRL: Liste par plante de specific root length (m.g-1)
    ## phmgPet: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (petioles)
    ## phmgEntr: Liste par plante d'effet maximum d'allongement du a la photomorphogenese (entrenoeuds)
    ## phmgPet_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (petioles)
    ## phmgEntr_m: Liste par plante d'effet maximum de reduction de croissance du a la photomorphogenese (entrenoeuds)
    ## dMSenFeuil: Liste par plante des delta de biomasse de feuille senescent (g.plant-1)
    ## dMSenTige: Liste par plante des delta de biomasse de tige (entre-noeud et petiole) senescent (g.plant-1)
    ## R_DemandC_Shoot: Liste par plante de ratio offre/demande C pour croissance minimu des tiges
    ## NBphyto: Liste par plante de nbr de phytomeres compte sur la nase des entre-noeuds presents
    ## germinaltion: liste of a logical value: 0=no germination, 1=germination, 2=1feuille visible
    
    #! RLentot va remplacer RLTot!
    
    
    invar = {'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'PARaPlanteU':[],'Hplante':[], 'Dplante':[], 'RLTot':[], 'RDepth':[], 'parap':[], 'parip':[], 'Mrac_fine':[], 'Mpivot':[], 'Maerien':[], 'Mfeuil':[],'Mcoty':[],'MS_rac_fine':[], 'MS_pivot':[], 'MS_aerien':[],'MS_feuil':[],'MS_aer_cumul':[], 'Mtot':[], 'MS_tot':[], 'DiampivMax':[], 'countSh':[], 'NBsh':[], 'NBI':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'DemandN_TotAer':[], 'NBD1':[], 'NBB':[], 'countShExp':[],'lsA':[],'lsAPrev':[],'lsApexMort':[], 'NBBexp':[], 'R_DemandC_Root':[],'RLen1':[], 'RLen2':[],'RLen3':[],'RLentot':[],'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[],'firstleaf':[], 'Naerien':[], 'Npc_aer':[], 'Npc_piv':[], 'Npc_rac_fine':[],'Nuptake_sol':[],'NNI':[], 'Ndfa':[], 'Qfix':[], 'TT':[],'TTsol':[], 'dTT':[], 'dTTsol':[], 'dMSenFeuil':[],'dMSenTige':[], 'R_DemandC_Shoot':[],'RUEactu':[], 'DemCp':[],'DemCp_lf':[],'L_Sp':[],'remob':[],'Nrac_fine':[], 'Npivot':[],'dRLen2':[],'dRLen3':[],'dMSenRoot':[],'dRLenSentot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'Surfcoty':[],'NBphyto':[],'germination':[],'MSgraine':[], 'Ngraine':[],'dMSgraine':[],'dNgraine':[], 'NBapexAct':[],'NreservPiv':[]} 
    
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]); invar['lsA'].append([]);invar['lsAPrev'].append([]);invar['lsApexMort'].append([])
    
    for i in range(nbplantes): invar['Hplante'].append(0.); invar['Dplante'].append(0.);invar['RLTot'].append(0.); invar['RDepth'].append(0.);invar['parap'].append(0.); invar['parip'].append(0.);invar['PARaPlanteU'].append(0.);invar['DiampivMax'].append(0.1); invar['countSh'].append(0);invar['NBsh'].append(0.);invar['NBI'].append(0.);invar['DemandN_Feuil'].append(0.);invar['DemandN_Pet'].append(0.);invar['DemandN_Stem'].append(0.);invar['DemandN_Tot'].append(0.);invar['NBD1'].append(0);invar['NBB'].append(0); invar['countShExp'].append(0);invar['NBBexp'].append(0); invar['R_DemandC_Root'].append(0);invar['RLen1'].append(0);invar['RLen2'].append(0);invar['RLen3'].append(0);invar['RLentot'].append(0);invar['SRL'].append(100.);invar['phmgPet'].append([1.]);invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.]);invar['firstleaf'].append(float("inf"));invar['MS_aer_cumul'].append(0.); invar['NNI'].append(1.); invar['Ndfa'].append(1.); invar['TT'].append(0.);invar['TTsol'].append(0.);invar['dTT'].append(0.);invar['dTTsol'].append(0.);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['R_DemandC_Shoot'].append(1.);invar['DemCp'].append(0.);invar['DemCp_lf'].append(0.);invar['MS_pivot'].append(0.);invar['remob'].append(0.);invar['RLTotNet'].append(0); invar['MS_rac_fineNet'].append(0);invar['perteN_rac_fine'].append(0);invar['NBphyto'].append(0);invar['germination'].append(0);invar['dMSgraine'].append(0.);invar['dNgraine'].append(0.);invar['NBapexAct'].append(0); invar['NreservPiv'].append(0)
    
    PG = array(riri.get_lsparami(ParamP, 'PMG'))/1000.
    invar['MSgraine'] = PG.tolist()
    invar['Mtot'].append(PG.tolist())
    invar['Ngraine'] = array(PG)*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.
    
    
    #invar['Maerien'].append(array(PG)*0.)
    #invar['Mpivot'].append(array(PG)*0.)
    #invar['Mfeuil'].append(array(PG)*0.)
    #invar['Mrac_fine'].append(array(PG)*0.)
    
    #initialisation avec des epsilon pour pas que ça bug?
    frac_coty_ini = array(riri.get_lsparami(ParamP, 'frac_coty_ini')) #0.5 ##a passer en parametre?
    PG = array(PG)*10e-15
    
    invar['Maerien'].append(array(PG)*frac_coty_ini) #4/5 va aerien
    invar['Mcoty'] = array(PG)*frac_coty_ini #dans les cotyledons
    invar['Mrac_fine'].append(array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine')))
    invar['Mpivot'].append(array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine'))))
    
    invar['Mfeuil'].append(array(PG)*frac_coty_ini) #tout aerien dans feuil
    invar['Naerien'] = array(PG)*frac_coty_ini*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Nrac_fine'] = array(PG)*(1.-frac_coty_ini)*array(riri.get_lsparami(ParamP, 'frac_rac_fine'))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    invar['Npivot'] = array(PG)*(1.-frac_coty_ini)*(1. - array(riri.get_lsparami(ParamP, 'frac_rac_fine')))*array(riri.get_lsparami(ParamP, 'Npc_ini'))/100.#meme teneur racine et shoot
    #Mtige pas explicite pour le moment
    
    # 2) INVAR_SC: variables a autres echelle que plante (un dico par echelle des surface, surface verte, PARa cumules)
    ## 3 echelles: plante = 'plt', tige ramifiee ='sh', Axe = 'ax'
    ## Surf: 
    ## SurfVerte: 
    ## PARaF:
    ## MaxPiv: dictionnaire par cle d'axe de biomasse cumulee par pivot
    ## DiampivMax: dictionnaire par cle d'axe de diametre max de pivot
    ## AgePiv: dictionnaire par cle d'axe d'age des pivot en TT
    
    invar_sc = {'plt':{}, 'sh':{}, 'ax':{}}
    #reorganiser invar sur la base de ces 3 echelles??
    invar_sc['ax']['MaxPiv']={}
    invar_sc['ax']['DiampivMax']={}
    invar_sc['ax']['AgePiv']={}
    invar_sc['ax']['DemCRac']={}
    invar_sc['ax']['OfrCRac']={}
    invar_sc['ax']['QDCRac']={}
    invar_sc['ax']['QDCmoyRac']={} #QD moyen integre dans le temps par pivot
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}
    invar_sc['ax']['StressHmoyRac']={}#stress hydrique moyen des racines par pivot integre dans le temps
    invar_sc['ax']['NRac']={}#liste de nb d'apex par ordre pour chaque pivot
    invar_sc['ax']['dlRac']={}#delta de longueur des racines par ordre
    invar_sc['ax']['cumlRac']={}#cumul de longueur de racine par ordre
    
    #pour stocker NI max
    invar_sc['sh']['MaxNI']={}#dev max des axes primaires -> pour gerer vitesse de redemarrage des pivots
    
    #3) Autres variables globales utilisees ds calcul
    ## lsAxes: liste d'apex I(axes) actifs (utilise dans calcLeafStemRatio)
    ## lsApex: liste d'apex I et II actifs (utilise dans calcNB_NI et cumul_lenIN)
    ## lsApexStop : liste d'apex I et II a l'arret 
    ## lsApexAll : liste de tous les apex I et II
    ## lsOrgans: liste des organes (Lf/Stp/In/Pet) sur tous les axes (utilise dans cumul_lenIN, calcOffreC, calcDemandeC) (ancien lsActiveAxes)
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    savelsOrgans=[]
    #for i in range(nbplantes): lsOrgans.append([]) #faire une liste d'organe par plante??
    
    
    #4)#initialisation des ls_systrac (#pour recuperer les enveloppes de racine par plante)
    ls_systrac = {} 
    for i in range(nbplantes):ls_systrac[i]=[]
    
    #5) initialisation des indices de stress par plante a 1. (devrait passer dans invar)
    ls_ftswStress = {'WaterTreshExpSurf':[], 'WaterTreshDevII':[] ,'WaterTreshDevI':[], 'WaterTreshFix':[],'WaterTreshRUE':[]}
    ls_NNIStress = {'NTreshRUE':[], 'NTreshExpSurf':[], 'NTreshDev':[], 'NTreshDevII':[]}
    for i in range(nbplantes): ls_ftswStress['WaterTreshExpSurf'].append(1.);ls_ftswStress['WaterTreshDevII'].append(1.);ls_ftswStress['WaterTreshDevI'].append(1.);ls_ftswStress['WaterTreshFix'].append(1.);ls_ftswStress['WaterTreshRUE'].append(1.);ls_NNIStress['NTreshRUE'].append(1.);ls_NNIStress['NTreshExpSurf'].append(1.);ls_NNIStress['NTreshDev'].append(1.);ls_NNIStress['NTreshDevII'].append(1.)
    
    #6) Variables de profil plante (surface/eaclairement/N)
    
    LAIprofil, SurfprofilPlant = {}, []
    for i in range(0, na[2]):  LAIprofil[i]=0.#initialise variables globales de profils
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIprofil))#liste de LAIprofil par plante
    
    deltaI_I0 = 0.05 #0.1 #delta entre classe d'aclairement relatif
    nbI_I0 = int(1./deltaI_I0) #nb classes d'eclairement relatif
    I_I0Classes = arange(deltaI_I0/2., 1.+deltaI_I0/2., deltaI_I0) #eclairememnt relatif moyen par classe
    I_I0profilLfPlant = [] #liste de surface de feuille par classe d'eclairement relatif
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee de petiole par classe d'eclairement relatif
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant) #liste de longueur cumulee d'entre-noeuds par classe d'eclairement relatif
    
    NaClasses = ParamP[0]['Na0']*Na_N0(I_I0Classes)#N0(INN=1.)*Na_N0(I_I0Classes)
    NlClasses = ParamP[0]['NL0Pet']*Na_N0(I_I0Classes)
    NlinClasses = ParamP[0]['NL0Sh']*Na_N0(I_I0Classes)
    # actuellement pas utilise -> serait a retirer proprement
    
    
    #variable de profil racine (a passer en dico?)
    res_root = [] 
    
    
    #RLProfil, RprospectProfil, rp0, rpp0 = [],[], {}, [] #liste de root length profil par horizon de sol; liste de profil des rayons de la racine primaire;rp0 et rpp0 sont les profils initiaux d'une plante, utilise pour faciliter l'instanciation de la liste de plantes
    #for i in range(0, ncouches_sol): rp0[i]=0.; rpp0.append(0.)
    #for i in range(nbplantes): RLProfil.append(deepcopy(rp0)); RprospectProfil.append(deepcopy(rpp0))
    
    
    return invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root




def init_outputs(ParamP, nbplantes):
    
    # 1) OUTVAR
    #dico de sorties
    outvar = {'colnames':[],'pattern':[],'TT':[],'TTsol':[], 'SurfPlante':[], 'PARaPlante':[], 'PARiPlante':[], 'epsi':[], 'Hplante':[], 'Dplante':[],'dMSaer':[],'RLTot':[], 'RDepth':[], 'MS_aerien':[],'MS_feuil':[],'MS_tot':[], 'countSh':[], 'demandC':[], 'Leaf_Stem':[], 'NBsh':[], 'NBI':[],'time':[],'FTSW':[],'Etransp':[], 'DemandN_Feuil':[], 'DemandN_Pet':[], 'DemandN_Stem':[],'DemandN_Tot':[], 'Npc':[], 'NBD1':[], 'NBB':[], 'countShExp':[], 'NBBexp':[], 'R_DemandC_Root':[], 'SRL':[],'phmgPet':[],'phmgEntr':[],'phmgPet_m':[],'phmgEntr_m':[], 'Naerien':[], 'Npc_aer':[], 'DemandN_Tot_Aer':[], 'Nuptake_sol':[], 'NNI':[], 'Ndfa':[], 'Qfix':[],'dMSenFeuil':[], 'dMSenTige':[],'MS_pivot':[],'MS_rac_fine':[],'R_DemandC_Shoot':[],'RUE':[],'BilanC_PARa':[], 'BilanC_RUE':[],'BilanCdMStot':[], 'BilanCdMrac_fine':[], 'BilanCdMpivot':[], 'BilanCdMaer':[],'BilanCdMSenFeuil':[],'BilanCdMSenTige':[], 'DemCp':[],'remob':[],'Npc_piv':[], 'Npc_rac_fine':[], 'dRLenSentot':[], 'dMSenRoot':[], 'RLTotNet':[], 'MS_rac_fineNet':[],'perteN_rac_fine':[],'NBphyto':[], 'cutNB':[],'NBapexAct':[]}
    outvar['pattern'].append(['pattern',0]+[surfsolref]*nbplantes)
    outvar['colnames'].append(['V1','steps']+riri.get_lsparami(ParamP, 'name')) #ajout des noms d'omglet en 1ere ligne
    
    # 2) Variables dynamique localisee du sol
    #id couches sorties sol (grand rhizotron)
    id_out = [0,1,4,11,17,25]# 5,10,25,60,90,130 cm, id de voxel dans le sol
    out_HR = [['DOY','HP5', 'HP10', 'HP25', 'HP60', 'HP90', 'HP130']]
    
    
    return outvar, id_out, out_HR




def convd(d):
    """ pour recupere sortie d'un dico profil en liste"""
    ks = d.keys()
    ks.sort()
    res=[]
    for k in ks: res.append(d[k])
    return res

def betaT(Tmin, Tmax, q, T):
    """ beta de Graux (2011)"""
    Tref = 20
    if T<0.:#zero sous zero degres
        fT=0.
    else:
        fT = ((Tmax-T)/(Tmax-Tref))*((T-Tmin)/(Tref-Tmin))**q
    
    return max(fT, 0.)

#plus utilise pour racines
def filtre_ratio(ratio, tresh=1.):
    """ pour filtrer les valeur < a un seuil - array de 0 et 1 """
    res = ratio>=tresh
    return res*1.

def dTT(T,p):
    """ fonction de cumul du temp thermique; integre reponse non lineaire"""
    return max((T-p[0])*betaT(p[1], p[2], p[3], T), 0.)

def DecliSun (DOY):
    """ Declinaison (rad) du soleil en fonction du jour de l'annee """
    alpha=2.*3.14*(DOY-1)/365.
    return (0.006918-0.399912*cos(alpha)+0.070257*sin(alpha))


def DayLength (latitude,decli):
    """ photoperiode en fonction de latitude (degre) et declinaison du soleil (rad) """
    lat=radians(latitude)
    d=arccos(-tan(decli)*tan(lat))
    if d<0:
        d=d+3.14
    
    #d en 'hour angle'
    return 24.*d/3.14 #conversion en heures


def expansion(t, a, delai):
    "croissance sigmoidale"
    return 1/(1+exp(-a*(t-delai)))

def sigmo_stress(v,delai,x):
    "reponse sigmo a stress - FTSW ou INN"
    return 1-1/(1+exp(v*(x-delai)))

#photomorphogenese
def trilineaire(x,ratio0,ratiomax,parmaxeff,parnoeff):
  pentor=(ratiomax-ratio0)/parmaxeff
  pentfin=(1-ratiomax)/(parnoeff-parmaxeff)
  orlindesc=-(parnoeff*pentfin)+1
  return min(pentor*x+ratio0,max(1,pentfin*x+orlindesc))

def rootalloc(params,SB):
  """ calcule fraction d'alloc racine/shoots en fonction du cumule shoots - Eq. 8 draft article V Migault"""
  """ puis concerti en fraction d'allocation de biomasse totale produite au racine dRB/dMStot a partir du ratio SRB/dSB"""
  res=[0]*nbplantes
  for nump in range(nbplantes):
      bet=params[nump][0]
      alph=params[nump][1]
      res[nump]=min(bet,bet*alph*max(SB[nump],0.00000000001)**(alph-1))#epsilon evitant de calculer un 0 avec puissance negative (cause erreur). Le maximum possible est pour alpha=1, donc beta*1*SB**(1-1) = beta * 1 * 1 = beta.
  
  dRB_dSB = array(res)
  return dRB_dSB/(1+dRB_dSB)



#def updateRootLenprofil(RLtot_, RprospectProfil_, RLProfil_):
#    if sum(RprospectProfil_)==0.:#secondaires pas developpees
#        RLProfil_[0] = RLtot_ #toute la surface d'echange dans le premier horizon
#    else:
#        vols = array(RprospectProfil_)*array(RprospectProfil_)
#        props = vols*1./sum(vols).tolist()
#        for k in range(len(RprospectProfil_)): 
#            RLProfil_[k] = RLtot_*props[k]
#     
#    return RLProfil_

def FTSW_resp(FTSW, par):#=[0.4, 0.]):
    #""" facteur de reduction en reponse a FTSW - lineaire entre 0 et 0.4"""
    """ reponse sigmo """
    res=1.
    #if FTSW <= par[1]:
    #    res=0.
    #elif FTSW > par[1] and FTSW < par[0]:
    #    res=FTSW/(par[0]-par[1])
    if FTSW<=0.95:
          res=sigmo_stress(par[0],par[1],FTSW)
    
    return res

def NNI_resp(NNI,par):
    #"""Belanger, Gastal and lemaire 1992 - RUE/RUEmax = f(Nitrogen Nutrition Index)"""
    #RUE_Eff= max(0,1.05*(1-2.18*exp(-3.13*NNI)))
    
    res=1.
    if NNI<0.95:
        res=sigmo_stress(par[0],par[1],NNI)
    
    return res#RUE_Eff

def Ndfa_max(ageTT, DurDevFix, Delfix=100.):
    """ Ndfa (prop d'N issu de fixation) max depend de stade - demare a 100 degree.days (Delfix -> a remonter en parametere)"""
    Delfix=0.
    slope = 1./(array(DurDevFix)-Delfix)
    ordoOr = -Delfix*slope
    val = slope*array(ageTT)+ordoOr
    val[val>1.] = 1.
    val[val<0.] = 0.
    return val
    #ages = [100., 200.]
    #DurDevFix = [600., 100.]
    #Ndfa_max(ages, DurDevFix)

def ActualFix(ls_demand, Nuptakes, MaxFix):
    """ calcul fixation a partir de demande, prelev mineral (prioritaire) et MaxFix """
    demande_residuelle = ls_demand - Nuptakes
    fix = []
    for i in range(len(demande_residuelle)):
        fix.append(min(MaxFix[i], demande_residuelle[i]))
    
    fix = array(fix)
    fix[fix<0] = 0.
    return fix
    #ls_demand = array([1.,2.,3.])
    #Nuptakes = array([1.,1.,1.])
    #MaxFix = array([3.,3.,3.])
    #ActualFix(ls_demand, Nuptakes, MaxFix)



def MaturBud(delaiMaturBud, NIparent, delta=4):
    """ genere ecart de stade des B() (en phyllocrones) selon stade de developpement tige parente et delaiMaturBud 
    - delta= borne min/max d'ecart par defaut +-4phyllo"""
    ecart = NIparent - delaiMaturBud
    if ecart>=0:
        ecart=min(delta, ecart)
    else:
        ecart=max(-delta, ecart)
    
    return ecart
    #MaturBud(delaiMaturBud=12, NIparent=15, delta=2)


def leg_leaf(Lmax, largmax, alpha=0., gamma=0., unifol=0):
    gamma = gamma*3.14/180 #en radians
    lf, la, pe, br, crois = 21./21., 6.5/21., 10./21., 3.6/21., 0.1/21. #leaf Trudeau modifie
    leaf = quadform (array([0.,0.,0.]), array([0.5,0.5,0.]), array([0.,1.,0.]), array([-0.5,0.5,0.]), opt=2)#prends pas alpha en compte
    leaf = transformation(leaf, largmax, Lmax, 1., 0,0,0,0,0,0)
    up = transformation(leaf, 1,1,1,0,0,gamma,0,pe/lf*Lmax,0)
    right = transformation(leaf, 1,1,1,-3.14/180*80,0,gamma, br/2.*Lmax, crois*Lmax,0)
    left = transformation(leaf, 1,1,1,3.14/180*80,0,gamma, -br/2.*Lmax, crois*Lmax,0)
    if unifol ==0:
        return Group([up, right, left])#groupe les differents geom
    else:
        return up#1 foliole pour la premiere feuille


def leg_leaf_lucas(Lmax, largmax, alpha=0., gamma=0., nfol=3, angfol=10., ecfol=6., anginit=45.,geom=True):#angfol : pi/nombre de rangs n?ssaires pour boucler le demi-cercle // ecfol : longueur de rachis entre chaque paire de folioles (mm).
    nr = (nfol-1)/2 if nfol%2==1 else nfol/2 #nombre de paires de folioles lateraux
    angfol=10#180/nr #demi-cercle complet obtenu sur le nombre de rangs de paires de folioles. Attention, ne marche que si l'ecartement ecfol est constant!
    gamma = gamma*3.14/180 #en radians
    anginit = anginit*3.14/180
    angfol = angfol*3.14/180
    ecfol = ((1.88*nfol**-0.54)*Lmax)*10 #relation empirique entre nombre de folioles et ecartement entre deux rang? pour le sainfoin. 
    
    ls_pts = []
    
    lf, la, pe, br, crois = 21./21., 6.5/21., 10./21., 3.6/21., 0.1/21. #leaf Trudeau modifie
    leaf = quadform (array([0.,0.,0.]), array([0.5,0.5,0.]), array([0.,1.,0.]), array([-0.5,0.5,0.]), opt=2)#prends pas alpha en compte
    leaf = transformation(leaf, largmax, Lmax, 1., 0,0,0,0,0,0)
    angup =(angfol*-(nr-1))-3.14-anginit #angle de placement du foliole central, au bout de la chaine
    up = transformation(leaf, 1,1,1,0,0,gamma,0, (pe/lf*Lmax)+(ecfol*(cos(angup)+cos(anginit))) , ecfol*(sin(angup)-sin(anginit)))
    ls_pts.append(array([0, (pe/lf*Lmax)+(ecfol*(cos(angup)+cos(anginit))) , ecfol*(sin(angup)-sin(anginit))]))
    #right = transformation(leaf, 1,1,1,-3.14/180*80,0,gamma, br/2.*Lmax, crois*Lmax,0)
    #left = transformation(leaf, 1,1,1,3.14/180*80,0,gamma, -br/2.*Lmax, crois*Lmax,0)
    listfol=[up] if nfol%2==1 else []
    for i in range(nr):#nombre de paires de folioles lateraux
        ang=(angfol*-i)-3.14-anginit
        ecfolopp = (sin(ang)-sin(anginit))*ecfol
        ecfoladj = (cos(ang)+cos(anginit))*ecfol
        listfol.append(transformation(leaf, 1,1,1,-3.14/180*80,0,gamma, br/2.*Lmax, ecfoladj,ecfolopp))
        listfol.append(transformation(leaf, 1,1,1,3.14/180*80,0,gamma, -br/2.*Lmax, ecfoladj,ecfolopp))
        ls_pts.append(array([br/2.*Lmax,ecfoladj,ecfolopp]))
        ls_pts.append(array([-br/2.*Lmax,ecfoladj,ecfolopp]))
        
    if geom==True:
        return Group(listfol)#groupe les differents geom
    else:
        return ls_pts


def geomstip(Lmax, largmax, alpha=0., gamma=0.):
    gamma = gamma*3.14/180 #en radians
    stip = quadform (array([0.,0.,0.]), array([0.5,0.5,0.]), array([0.,1.,0.]), array([-0.5,0.5,0.]), opt=2)#prends pas alpha en compte
    stip = transformation(stip, largmax , Lmax, 1., 0,0,0,0,0,0)
    if Lmax>=largmax:
        right = transformation(stip, 1,1,1,-3.14/180*alpha,-gamma,0, 0, 0 ,0)
        left = transformation(stip, 1,1,1,3.14/180*alpha,gamma,0, 0,0,0)
    else:
        right = transformation(stip, 1,1,1,-3.14/180*alpha,0,gamma, 0, 0 ,0)
        left = transformation(stip, 1,1,1,3.14/180*alpha,0,gamma, 0,0,0)
    return Group([right, left])
    #par convention choisi longueur dans direction du petiole?
    #faire porter gamma sur la plus grande direction -> marche normalement pour pois 
    #reprendre gammaFeuil pour le gamma (pas IncPet petiole)

def calc_surF(nump, rank, rankp, ordre, l): 
    """ calcul de surface d'une feuille (m2) """
    cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
    rk = rank+rankp if ordre==2 else rank
    rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou rank depasse le profil
    nf = ParamP[nump]['profilLeafI_nfol'][rk] 
    Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
    larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
    surF = nf*0.5*Long*larg/10000. #nf*0.5*Long*larg/10000.  #m2
    return surF
    #ParamP en parametre

def calc_surS(nump, rank, rankp, ordre, l): 
    """ calcul de surface d'une stipule (m2) """
    cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
    rk = rank+rankp if ordre==2 else rank
    rk = min(rk, len(ParamP[nump]['profilStipI_l'])-1) #au cas ou rank depasse le profil
    Long  = ParamP[nump]['profilStipI_l'][rk]*l*cor_ordre
    larg = ParamP[nump]['profilStipI_larg'][rk]*l*cor_ordre
    surF = 2*Long*larg*0.5/10000. #m2
    return surF
    #ParamP en parametre

def calc_surfcoty(Mcoty, age, DurGraine, carto, SLAcoty=600.):
    """ distribution de surface coty dans grille 3D - depend de masse de coty et SLAcoty et graine; et zero apres DurGraine"""
    #valeur de 600 tiree essai RGR2015
    #peut passer SLAcoty en parametre et variable par plante
    mcot = zeros([n_gamagroup, na[2], na[1], na[0]])
    
    for nump in range(len(carto)):
        vox = riri.WhichVoxel(array(carto[nump]), origin_grid, na, dxyz)
        if age[nump]<=DurGraine[nump]:#cotyledons actifs pendant DurGraine
            surfcot = Mcoty[nump]*SLAcoty/10000. #m2
        else:
            surfcot = 0.
        
        mcot[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surfcot
        
    return mcot


def calc_parapcoty(m_lais, res_abs_i, Mcoty, age, DurGraine, carto, SLAcoty=100.):
    """ ajout des PARa des cotyledon a invar['PARiPlante']"""
    for nump in range(len(carto)):
        vox = riri.WhichVoxel(array(carto[nump]), origin_grid, na, dxyz)
        sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]
        if age[nump]<=DurGraine[nump]:#cotyledons actifs pendant DurGraine
            surfcot = Mcoty[nump]*SLAcoty/10000. #m2
        else:
            surfcot = 0.
        
        if sVOX>0.:
            PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surfcot/sVOX *3600.*24/1000000.
        else:
            PARaF = 0.
        
        invar['PARiPlante'][nump].append(PARaF)


def germinate(invar, ParamP, nump):
    #mis a jour pour chaque graine a germination
    #creation des cotyledons
    frac_coty_ini = ParamP['frac_coty_ini']
    invar['Mcoty'][nump] = invar['MSgraine'][nump] * frac_coty_ini
    #invar['Mfeuil'][nump] = invar['MSgraine'][nump] * frac_coty_ini
    #invar['Naerien'][nump] = invar['Mfeuil'][nump] * ParamP['Npc_ini']/100.
    #met a jour graine qui a germe et defini pools de reserve (ce qui reste dans MSgraine et N graine = reserve pour soutenir croissance ini)
    invar['MSgraine'][nump] -= invar['Mcoty'][nump]
    invar['Ngraine'][nump] -= invar['Mcoty'][nump] * ParamP['Npc_ini']/100.
    invar['dMSgraine'][nump] = invar['MSgraine'][nump] / ParamP['DurGraine'] #delta MS fourni par degrejour par graine pendant DurGraine
    invar['dNgraine'][nump] = invar['Ngraine'][nump] / ParamP['DurGraine'] #delta QN fourni par degrejour par graine pendant DurGraine
    
    #cotyledons meurent quand DurGraine atteint -> cf calc_surfcoty    
    #en toute logique pas besoin de mettre a jour Mfeuil?     
    
    #passer frac_coty_ini dans ParamP?


def reserves_graine(invar, ParamP):
    """ calcul des reserves de graine """
    graineC, graineN = [], []
    for nump in range(len(ParamP)):
        if invar['TT'][nump]<ParamP[nump]['DurGraine'] and invar['TT'][nump]>0.:
            #suppose consommation reguliere pendant DurGraine
            dMSgraine = invar['dMSgraine'][nump]*invar['dTT'][nump]
            dNgraine = invar['dNgraine'][nump]*invar['dTT'][nump]
        else:
            dMSgraine = 0.
            dNgraine = 0.
        
        graineC.append(dMSgraine)
        graineN.append(dMSgraine)
    
    return array(graineC), array(graineN)



def calc_Lpet(nump, rank, rankp, ordre, l):
    """ calcule de longueur d'un petiole (m)"""
    cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
    rk = rank+rankp if ordre==2 else rank #fonction du rang comme pour feuille
    rk = min(rk, len(ParamP[nump]['profilPetI_l'])-1) #au cas ou rank depasse le profil
    lpet = l*ParamP[nump]['profilPetI_l'][rk]*cor_ordre/100. #m
    return lpet 
    #ParamP en parametre

def calc_Lent(nump, rank, nsh, ordre, l):
    """ calcule de longueur d'un entre noeud (m)"""
    cor_M = ParamP[nump]['ratioM'] if nsh==0 and ordre==1 else 1. #correction tige seminale
    cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1. 
    rank = min(rank, len(ParamP[nump]['profilNodeI_l'])-1) #au cas ou rank depasse le profil
    lent = l * ParamP[nump]['profilNodeI_l'][rank] * cor_ordre * cor_M/100. #m
    return lent
    #ParamP en parametre



def dic2vec(nbplantes, dic):
    """ mise en liste 'nump'par plante un dico deja par plante """
    res3 = []
    for nump in range(nbplantes):
        try:
            key_ = str(nump)
            res3.append(dic[key_])
        except:
            res3.append(0.)
    
    return res3

def dic_sum(ls_dict):
    "somme par cle les element de dico d'un meme format ; e.g [{0: 0, 1: 1, 2: 2}, {0: 3, 1: 4, 2: 5}] "
    #prepa d'un dico nul avec meme cles
    res = {}    
    for k in ls_dict[0].keys(): res[k]=0.
    #somme des dico
    for k in ls_dict[0].keys():
        for i in range(len(ls_dict)):
            res[k] += ls_dict[i][k]
    
    return res

def append_dic(dic, key, element):
    """ add an element to a list in a dictionnary or create the list if the key is not present"""
    try:
        dic[key].append(element)
    except:
        dic[key] = [element]

def add_dic(dadd, dini):
    """ add the values of the k keys of a dictionary dadd to an existing dictionnary dini with the same keys - creates keys in dini if not already existing"""
    for k in dadd.keys():
        try:
            dini[k] += dadd[k]
        except:
            dini[k] = dadd[k]
    return dini


def sum_ls_dic(dic):
    """ sum of the element by keys in a dictionnary of lists """
    for k in dic.keys(): 
        dic[k]=sum(dic[k])

def calcOffreC (tab, scale):
    """ calcul de cumul de para par plante ('plt')/tige('sh')/axe('ax') * RUE-> offreC """
    """ tab = attend dico avec cle ('nump', 'nsh', 'rank', 'PARaF','statut','age','ordre') """
    dp= {}#dictionnaire a l'echelle choisie: plnate/shoot/axe
    for i in range(len(tab['nump'])):
        if scale=='plt':
            idp = str(tab['nump'][i])
        elif scale=='sh':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])
        elif scale=='ax':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])+'_'+str(tab['rank'][i])
        
        if tab['organ'][i]=='Lf' and tab['statut'][i]!='sen' :
            nump = int(tab['nump'][i])
            try:
                dp[idp].append(float(tab['PARaF'][i])*ParamP[nump]['RUE'])
            except:
                dp[idp] = [float(tab['PARaF'][i])*ParamP[nump]['RUE']]
    
    for k in dp.keys(): 
        dp[k]=sum(dp[k])
    
    return dp
    #approche RUE limite a echelle feuille! ; garder aussi 'sen'?
    

def calcSurfScale(tab, scale):
    """ calcul le cumul de surface foliaire a l'echelle indiquee """
    dp= {}#dictionnaire a l'echelle choisie: plante/shoot/axe
    for i in range(len(tab['nump'])):
        if scale=='plt':
            idp = str(tab['nump'][i])
        elif scale=='sh':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])
        elif scale=='ax':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])+'_'+str(tab['rank'][i])
        
        age = float(tab['age'][i])
        nump = int(tab['nump'][i])
        ordre = int(tab['ordre'][i])
        rank = int(tab['rank'][i])
        rankp = int(tab['rankp'][i])
        nsh = int(tab['nsh'][i])
        l = float(tab['l'][i])
        
        surf=0.
        if tab['organ'][i]=='Lf':
            surf = calc_surF(nump, rank, rankp, ordre, l)#m2
        
        if tab['organ'][i]=='Stp':
            surf = calc_surS(nump, rank, rankp, ordre, l)#m2
        
        #ajoute une cle pour chaque organe (meme si pas feuille)
        try:
            dp[idp].append(surf)
        except:
            dp[idp] = [surf]
        
    for k in dp.keys(): 
        dp[k]=sum(dp[k])
    
    return dp
    #lsSurfSh = calcSurfScale(IOtable.conv_dataframe(IOtable.t_list(lsOrgans)), 'sh')
    #plus utile car fait dans calcSurfLightScales


def calcSurfLightScales(tab):
    """ calcul le cumul de surface foliaire, surface foliaire verte et PARa au echelles plante/shoot_axe - passe la table organe une seulle fois en revue """
    
    daxAgePiv = {}#dico des axes qui portent des pivots et de leur age
    dpS, dpSV, dpPARaF, dshS, dshSV, dshPARaF, daxS, daxSV, daxPARaF, daxPARaFsurf = {}, {}, {}, {}, {}, {} , {}, {}, {}, {}
    for i in range(len(tab['nump'])):
        
        idp = str(tab['nump'][i])
        idsh = str(tab['nump'][i])+'_'+str(tab['nsh'][i])
        idax = str(tab['nump'][i])+'_'+str(tab['nsh'][i])+'_'+str(tab['rank'][i])
        
        age = float(tab['age'][i])
        nump = int(tab['nump'][i])
        ordre = int(tab['ordre'][i])
        rank = int(tab['rank'][i])
        rankp = int(tab['rankp'][i])
        nsh = int(tab['nsh'][i])
        l = float(tab['l'][i])
        
        surf, surfV, PARaF, PARaFsurf = 0. , 0., 0., 0.
        if tab['organ'][i]=='Lf':
            PARaF = float(tab['PARaF'][i])
            surf = max(calc_surF(nump, rank, rankp, ordre, l), 10e-15)#m2
            PARaFsurf = PARaF/(surf*3600.*24/1000000.)#
            if tab['statut'][i]!='sen':
                surfV = surf
        
        if tab['organ'][i]=='Stp':
            PARaF = float(tab['PARaF'][i])
            surf = calc_surS(nump, rank, rankp, ordre, l)#m2
            if tab['statut'][i]!='sen':
                surfV = surf
        
        if tab['organ'][i]=='Piv':
            daxAgePiv[idax] = age
        
        #ajoute une cle pour chaque organe (meme si pas feuille)
        append_dic(dpS, idp, surf)
        append_dic(dshS, idsh, surf)
        append_dic(daxS, idax, surf)
        append_dic(dpSV, idp, surfV)
        append_dic(dshSV, idsh, surfV)
        append_dic(daxSV, idax, surfV)
        append_dic(dpPARaF, idp, PARaF)
        append_dic(dshPARaF, idsh, PARaF)
        append_dic(daxPARaF, idax, PARaF)
        append_dic(daxPARaFsurf, idax, PARaFsurf)
    
    sum_ls_dic(dpS) #surface par plante
    sum_ls_dic(dpSV) #surface par shoot
    sum_ls_dic(dshS) #surface par axe
    sum_ls_dic(dshSV) #surface verte par plante
    sum_ls_dic(daxS) #surface verte par shoot
    sum_ls_dic(daxSV) #surface verte par axe
    sum_ls_dic(dpPARaF) #PARaF par plante
    sum_ls_dic(dshPARaF) #PARaF par shoot
    sum_ls_dic(daxPARaF) #PARaF par axe
    for k in daxPARaFsurf.keys(): 
        daxPARaFsurf[k]=max(daxPARaFsurf[k])
    
    return dpS, dpSV, dshS, dshSV, daxS, daxSV, dpPARaF, dshPARaF, daxPARaF, daxAgePiv, daxPARaFsurf
    #ajouter calcul du max de rayonnement par axes...?-> daxPARaFsurf


def calcDemandeC(tab, scale, dTT):
    """ calcul de demande pour assurer croissance potentielle minimale des Lf() et In() et Pet()en phase d'expansion """
    #!distinguer les Lf et Stp! car pas meme calcul de surface!
    dp= {}#dictionnaire a l'echelle choisie: plante/shoot/axe #-> demande tot
    dplf= {}#demande des feuilles
    for i in range(len(tab['nump'])):
        if scale=='plt':
            idp = str(tab['nump'][i])
        elif scale=='sh':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])
        elif scale=='ax':
            idp = str(tab['nump'][i])+'_'+str(tab['nsh'][i])+'_'+str(tab['rank'][i])
        
        age = float(tab['age'][i])
        nump = int(tab['nump'][i])
        ordre = int(tab['ordre'][i])
        rank = int(tab['rank'][i])
        rankp = int(tab['rankp'][i])
        nsh = int(tab['nsh'][i])
        l = float(tab['l'][i])
        
        if tab['organ'][i]=='Lf' and tab['statut'][i] == 'exp' :
            pot = expansion(age+dTT[nump], ParamP[nump]['aF'], ParamP[nump]['delaiF']) - expansion(age, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
            dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            dSpot = calc_surF(nump, rank, rankp, ordre, l+dl) - calc_surF(nump, rank, rankp, ordre, l)#m2, delta surf potentiel (sans limitation C mais avec stress hydrique)
            dMin = 10000.*dSpot/ParamP[nump]['SLAmin']#delta masse min feuille
            append_dic(dp, idp, dMin)
            append_dic(dplf, idp, dMin)
        
        if tab['organ'][i]=='Stp' and tab['statut'][i] == 'exp' :
            pot = expansion(age+dTT[nump], ParamP[nump]['aS'], ParamP[nump]['delaiS']) - expansion(age, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            dSpot = calc_surS(nump, rank, rankp, ordre, l+dl) - calc_surS(nump, rank, rankp, ordre, l)#m2, delta surf potentiel (sans limitation C mais avec stress hydrique)
            dMin = 10000.*dSpot/ParamP[nump]['SLAmin']#delta masse min feuille
            append_dic(dp, idp, dMin)
            append_dic(dplf, idp, dMin)
        
        if tab['organ'][i]=='In' and tab['statut'][i] == 'exp' :
            pot = expansion(age+dTT[nump], ParamP[nump]['aE'], ParamP[nump]['delaiE']) - expansion(age, ParamP[nump]['aE'], ParamP[nump]['delaiE'])
            dl = pot * ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            dLpot = calc_Lent(nump, rank, nsh, ordre, dl)#m, delta longueur potentiel (sans limitation C mais avec stress hydrique)
            dMin = dLpot/ParamP[nump]['SNLmin']#delta masse min En
            append_dic(dp, idp, dMin)
        
        if tab['organ'][i]=='Pet' and tab['statut'][i] == 'exp' :
            pot = expansion(age+dTT[nump], ParamP[nump]['aP'], ParamP[nump]['delaiP']) - expansion(age, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
            dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            dLpot = calc_Lpet(nump, rank, rankp, ordre, dl)#m
            dMin = dLpot/ParamP[nump]['SPLmin']#delta masse min En
            append_dic(dp, idp, dMin)
    
    sum_ls_dic(dp)
    sum_ls_dic(dplf)
    
    return dp, dplf
    #pourrait decliner demande globale en demande par organe?


def Cremob(DemCp, R_DemandC_Shoot, MSPiv, frac_remob = 0.1):
    """ remobilisation of C from the taproot to the shoot to ensure minimal growth """
    #frac_remob : fraction remobilisable du pivot par jour (a passer en parametre?)
    ratio_seuil = array(deepcopy(R_DemandC_Shoot))
    ratio_seuil[ratio_seuil>1.]=1.#borne ratio demande a 1
    dem_non_couv = array(DemCp)*(1-ratio_seuil)
    dem_non_couv_dispo = frac_remob*array(MSPiv)-dem_non_couv#depend d'un fraction remobilisable du pivot par jour
    dem_non_couv_dispo[dem_non_couv_dispo<0] = dem_non_couv [dem_non_couv_dispo<0]+dem_non_couv_dispo[dem_non_couv_dispo<0]#borne remobilisation a poids du pivot
    remob = deepcopy(dem_non_couv_dispo)
    remob[dem_non_couv<=0.]=0. #met a zero si couvert
    for i in range(len(remob)):
        remob[i] = min(remob[i], dem_non_couv[i])
    
    return remob


#a retirer
def calcLeafStemRatio(tab,lsapexI):
    """ calcul de rapport feuille/tige base sur les tigeI actives"""
    #etablit une liste de tige avec A() actif (lsa)
    lsa = []
    for i in range(len(lsapexI)):
        newk = str(lsapexI[i][0])+'_'+str(lsapexI[i][1]) #id = 'nump_nsh'
        lsa.append(newk)
    
    #recupere les masses mini des feuilles et tiges des lsa
    dp, dp2 = {}, {}
    for i in range(len(tab['nump'])):
        idp = str(tab['nump'][i])
        idt = str(tab['nump'][i])+'_'+str(tab['nsh'][i])
        
        age = float(tab['age'][i])
        nump = int(tab['nump'][i])
        ordre = int(tab['ordre'][i])
        rank = int(tab['rank'][i])
        rankp = int(tab['rankp'][i])
        l = float(tab['l'][i])
        
        if tab['organ'][i]=='Lf' and idt in lsa:
            surf = calc_surF(nump, rank, rankp, ordre, l) #m2
            MLf = 10000.*surf/ParamP[nump]['SLAmin']#masse min feuille
            append_dic(dp, idp, MLf)
        
        if tab['organ'][i]=='In' and idt in lsa:
            cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1. 
            rank = min(rank, len(ParamP[nump]['profilNodeI_l'])-1)#au cas ou profil trop long
            Long = l * ParamP[nump]['profilNodeI_l'][rank] * cor_ordre /100. #m #delta de longueur potentiel (sans limitation C)
            MIn = Long/ParamP[nump]['SNLmin']
            append_dic(dp2, idp, MIn)
    
    #fait somme par plante de Lf et In, puis ratio
    for k in dp.keys():
        leafM = sum(dp[k])
        try:
            inM = sum(dp2[k])+0.00000000001
        except:
            inM = 0.00000000001
        
        dp[k]=leafM/inM
    
    return dp

def calcNB_NI(tab, seuilcountTige=0.5, seuilNItige=0.75):
    """ tab = tableau des apex actifs I et II =lsApex ; seuilNItige: faut au moins cette fraction du max pour etre compter en NI; seuilcountTige: pareil pour etre compter dans le nb tige 'significatives' """
    resall, resI, resNI, resNB = [],[],[],[]
    for i in range(nbplantes): 
        resall.append([0]);resI.append([0]);resNI.append([]);resNB.append([])
    
    for i in range(len(tab)):
        idp = int(tab[i][0])
        resall[idp].append(tab[i][2])
        if tab[i][3]==1:
            resI[idp].append(tab[i][2])
    
    for i in range(nbplantes): 
        resall[i]=max(resall[i])
        resI[i]=max(resI[i])
    
    for i in range(len(tab)):
        idp = int(tab[i][0])
        if float(tab[i][2]) > seuilcountTige*float(resall[idp]):
            resNB[idp].append(tab[i][2])
        
        if tab[i][3]==1 and float(tab[i][2]) > seuilNItige*float(resI[idp]):
            resNI[idp].append(float(tab[i][2]))
    
    for i in range(nbplantes): 
        resNB[i]=len(resNB[i]); resNI[i]=mean(resNI[i])
    
    return resNB, resI 

def cumul_lenIN(tab, tabL, I_I0profilInPlant_):
    """ tab = tableau des apex actifs I et II =lsApex ;tabL = lsOrgans converti en dico"""
    #ajoute un id tige a tab lsApex en derniere colone
    for i in range(len(tab)):tab[i].append(str(tab[i][0])+'_'+str(tab[i][1])) 
    #liste d'id tiges unique
    tab = IOtable.t_list(tab)
    id_sh = list(set(tab[-1])) #id tige dans derniere colone
    tab = IOtable.t_list(tab)
    
    #dico des I_I0 max par tige
    res = dict.fromkeys(id_sh, 0) 
    for i in range(len(tab)):
        id = tab[i][-1]
        I_I0 = tab[i][4]
        if I_I0 > res[id]:
            res[id]=I_I0
    
    #dico des longueur cumul par tige
    resL = {}#dict.fromkeys(id_sh, 0) 
    for i in range(len(tabL['organ'])):
        if tabL['organ'][i] == 'In':
            id = str(tabL['nump'][i])+'_'+str(tabL['nsh'][i])
            try:
                resL[id] += tabL['Long'][i]/100. #m
            except:#si pas dans les cles, la cree
                resL[id] = tabL['Long'][i]/100.#pass
    
    #mise a jour des longueur de tige par classe d'eclairement
    for id in res.keys():
        nump = map(int, string.split(id, '_'))[0]
        I_I0 = res[id]
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        try :
            cumulL = resL[id]
        except:#pas encore de In
            cumulL = 0.
        
        I_I0profilInPlant_[nump][classI_I0] += cumulL
    
    return I_I0profilInPlant_ # resL
#bizarre -> donne meme longueur pour tous les axes??
#faire dico tige pour toutes les tiges et croiser apres avec activeAxes?
#a continuer avec un profil de longueur par I_I0



def Start():
    
    #initialisation des variables globale de simulation
    global DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard
    
    DOY, TT, TTsol, meteo_j, mng_j, STEPS_, STEPSsol_, ls_epsi, TT_repousse, isTTcut, isRegrowth, cutNB, Hcut, start_time, past_time, test_retard = init_glob_variables_sim(meteo, mng, DOYdeb, deltalevmoy, deltalevsd)
    
    # initialisation des parametres plante
    global ParamP, nbplantes
    global ongletP, ongletPvois, optdamier, typearrangement
    #ongletP = 'Fix1'#'Fix'#'timbale'#'formica'#'canto'#'giga'##'alfalfa'#'geno_test'#'G3'#'C1'#'8_2'#'kayanne'#'leo'#'G1'#'timbale'##
    #ongletPvois = 'nonFix2'#'nonFix0'#'alfalfa'#'geno_test'#'G3'#
    #optdamier = 4
    #typearrangement='damier8'    
    ParamP, nbplantes = init_ParamP(path_plante, ongletP, ongletPvois, nbcote, type=typearrangement, opt=optdamier, ongletScenar1=ongletScenar1, ongletScenar2=ongletScenar2,idscenar1=idscenar1, idscenar2=idscenar2)
    
    
    #initialisation de la scene
    global carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr 
    
    carto, distplantes, pattern8, Lsol, largsol, surfsolref, dz_sol, ncouches_sol, prof_sol_max, discret_solXY, lims_sol, ls_gammagroup, setp, n_gamagroup, na, dxyz, lims_aer, origin_grid, surf_refVOX, m_lais, m_lais_construct, triplets, ls_dif, res_trans, res_abs_i, res_rfr = init_scene(ParamP, inis, cote, nbcote, dz_aerien, Hmaxcouv)
    
    #initialisation du sol
    global S, Tsol, Uval, stateEV, b_,  obstarac_, ls_mat_res, setr
    S, Tsol, Uval, stateEV, b_ = init_sol(inis, meteo_j, par_sol, par_SN, Lsol, discret_solXY, dz_sol,obstarac_)
    #mat_res = 0.*S.m_1 #en faire 
    ls_groupe_resid = map(int, riri.get_lsparami(ParamP, 'groupe_resid'))
    setr = list(set(ls_groupe_resid)) #set equivalent fonction r.unique!
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des esidu de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    
    print len(ls_mat_res) #= [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]
    
    #initialisation des variables d'etat plante
    global invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root 
    
    invar, invar_sc, lsAxes, lsApex, lsApexStop, lsApexAll, lsOrgans, savelsOrgans, ls_systrac, ls_ftswStress, ls_NNIStress, LAIprofil, SurfprofilPlant, deltaI_I0, nbI_I0, I_I0Classes, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, NaClasses, NlClasses, NlinClasses, res_root = init_variables_plantes(ParamP, nbplantes)
    
    #initialisation des sorties
    global outvar, id_out, out_HR
    outvar, id_out, out_HR = init_outputs(ParamP, nbplantes)
    
    
    
    ##seed nombre aleatoires
    global Rseed
    random.seed(Rseed)
    seed(Rseed)
    #ajout des profils de taille potentiel par rang dans ParamP (calcule 1 seul fois) (cm) / parametres de morpho racine par ordre
    
    # pour gerer sortie visuelle en batch - Lucas
    #frameDisplay(True)





def StartEach():
    global TT,TTsol, STEPS_, STEPSsol_, isTTcut, TT_repousse,  SurfprofilPlant, nbplantes, lsAxes, lsApex,lsApexAll, lsApexStop,lsOrgans, m_lais, res_trans, res_abs_i, res_rfr, m_lais_construct, I_I0profilLfPlant, I_I0profilPetPlant, I_I0profilInPlant, invar, ls_systrac, Hcut, cutNB #utilise dz, I0, k (global pas mis a jour)#Hmaxcouv, LAIvois, PARt,
    
    #calcul TT
    STEPS_ = dTT(meteo_j['TmoyDay'], [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']]) #prend valeur de nump=0 -> reference pour la simulation!
    TT = TT+STEPS_
    STEPSsol_ = dTT(meteo_j['Tsol'], [ParamP[0]['Tdev'], ParamP[0]['Tmin'], ParamP[0]['Tmax'], ParamP[0]['q']])
    TTsol = TTsol + STEPSsol_
    
    for nump in range(nbplantes): 
        invar['dTT'][nump] = dTT(meteo_j['TmoyDay'], [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']])
        invar['dTTsol'][nump] = dTT(meteo_j['Tsol'], [ParamP[nump]['Tdev'], ParamP[nump]['Tmin'], ParamP[nump]['Tmax'], ParamP[nump]['q']])
        
        if invar['germination'][nump]>0:
            invar['TT'][nump] = invar['TT'][nump] + invar['dTT'][nump]
            invar['TTsol'][nump] = invar['TTsol'][nump] + invar['dTTsol'][nump]
    
    
    #calcul profil surface couvert et calcul de PAR voxel
    mlaicot = calc_surfcoty(invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto) #ajoute surface des cotyledons
    m_lais = deepcopy(m_lais_construct) + mlaicot
    #plante qd ajoute mlaicot?? -> OK unite
    #pb: toujours surplante de zero et pas de production de biomasse
    
    res_trans, res_abs_i = riri.calc_extinc_allray_multi(m_lais/surf_refVOX, triplets , ls_dif , meteo_j['I0']*surf_refVOX, optsky='soc')
    res_rfr = riri.rfr_calc_relatif(res_trans/(meteo_j['I0']*surf_refVOX))#calcul de zeta
    m_lais_construct = zeros([n_gamagroup, na[2], na[1], na[0]])
    
    
    
    
    #remise a zero LAIprofilplant pour nouvelle iteration  
    LAIp  = {}
    for i in range(0, len(SurfprofilPlant[0].keys())): LAIp[i]=0.
    SurfprofilPlant = [] #liste de LAIprofil par plante
    for i in range(nbplantes): SurfprofilPlant.append(deepcopy(LAIp))
    I_I0profilLfPlant = []
    for i in range(nbplantes): I_I0profilLfPlant.append(zeros(nbI_I0))
    I_I0profilPetPlant = deepcopy(I_I0profilLfPlant)
    I_I0profilInPlant = deepcopy(I_I0profilLfPlant)
    
    #if TT%TTcutFreq <STEPS:
    if mng_j['Coupe']==1:
        Hcut = mng_j['Hcut']
        print 'cut ', Hcut
        isTTcut = True
        isRegrowth = True
        cutNB += 1
        TT_repousse = TT
        invar['Maerien'] = [array([1e-15]*nbplantes)] #mise a epsilon - discutable: biomasse residuelle peut ne pas etre negligeable! trefle..
        invar['Mfeuil'] = [array([1e-15]*nbplantes)] #tout l'aerien
        invar['Naerien'] = invar['Maerien'][0]*invar['Npc_aer']/100. #remet avec teneur en N conservee par rapport a avant la coupe
        #invar['Naerien'] = []
        #for nump in range(nbplantes): 
        #    #invar['MS_aerien'][nump] = 1e-15 
        #    invar['Naerien'][nump] = 1e-15*invar['Npc_bis'][nump]/100. #remet avec teneur en N conservee par rapport a avant la coupe
    else:
        isTTcut = False
    
    #calcul offre/demandeC sur la base des tableaux precedent avant leur remise a zero
    tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    OffCp = calcOffreC (tab, 'plt')#pas utilise??!
    invar['DemCp'], invar['DemCp_lf'] = calcDemandeC(tab, 'plt',invar['dTT'])#attention, pour que calcul soit bon, faut le STEPS  suivant mis a jour!-> a faire en StartEach
    #invar['L_Sp'] = calcLeafStemRatio(tab, lsAxes)

    #sortie    
    lsAxes = []
    lsApex = []
    lsApexStop = []
    lsApexAll = []
    lsOrgans =[['TT','organ','nump', 'nsh', 'rank', 'rankp', 'strate', 'surf', 'PARaF','statut','age','ordre','l','Long','DOY','cutNB', 'Larg']]
    ls_systrac = {}
    
    invar['lsAPrev'] = invar['lsA']
    invar['SurfPlante'], invar['PARaPlante'], invar['PARiPlante'], invar['NBD1'],invar['NBB'],invar['lsA'],invar['NBBexp'],invar['dMSenFeuil'] ,invar['dMSenTige'],invar['NBphyto'],invar['NBapexAct'] = [], [], [],[],[],[],[],[],[],[],[]
    for i in range(nbplantes): invar['SurfPlante'].append([]); invar['PARaPlante'].append([]); invar['PARiPlante'].append([]);invar['NBD1'].append(0) ; invar['NBB'].append(0);invar['NBBexp'].append(0);invar['lsA'].append([]);ls_systrac[i]=[]; invar['phmgPet'].append([1.]);invar['dMSenFeuil'].append(0.);invar['dMSenTige'].append(0.);invar['NBphyto'].append(0.);invar['NBapexAct'].append(0)
    
    #ls_systrac[i]=[[carto[nump][0],carto[nump][1],0.,0.01,0.01]] #pour initialiser avec une racine et pas faire planter sol - pose pb seulement avant 1er step
    
    #initialisation des invar['PARiPlante'] avec ajout des PARi cotyledon:
    calc_parapcoty(m_lais, res_abs_i, invar['Mcoty'], invar['TT'], riri.get_lsparami(ParamP, 'DurGraine'), carto) 
    
    #sorties photomorphogenese
    for i in range(nbplantes): invar['phmgEntr'].append([1.]);invar['phmgPet_m'].append([1.]);invar['phmgEntr_m'].append([1.])
    
    invar_sc['ax']['StressHRac']={}
    invar_sc['ax']['PonderStressHRac']={}


def EndEach(lstring):
    #sorties
    global   S, Uval, stateEV, DOY, meteo_j,mng_j,  PP, res_root, nbplantes, surfsolref, ls_ftswStress,past_time, I_I0profilInPlant,lsOrgans, Uval2, stateEV2,ls_NNIStress, ls_mat_res #,Et0,SurfPlante, PARaPlante, PARiPlante,Hplante, Dplante, RLTot,RDepth,dpar, Mrac_fine, Mpivot,DiampivMax, RprospectProfil, RLProfil,
    
    #calcul de ls_epsi
    invar['parap'] = array(map(sum,invar['PARaPlante']))
    invar['parip'] = array(map(sum,invar['PARiPlante']))
    #qatot= sum(res_trans[-1][:][:])*3600.*24/1000000. + sum(invar['parip'])#(MJ.day-1) #approximatif! a reprendre avec un vrai bilan radiatif
    #print sum(res_trans[-1][:][:]), sum(res_trans[-1][:][:])*3600.*24/1000000., sum(res_trans[-1][:][:])*3600.*24/1000000.  +   sum(invar['parip'])
    #ls_epsi = invar['parip']/qatot.tolist() #a reprendre : approximatif slmt! -> changera un peu avec un vrai bilan radiatif
    #transmi_sol = 1-sum(ls_epsi)
    #epsi = 1-transmi_sol #a reprendre pour differencier cible et vois #
    transmi_sol = sum(res_trans[-1][:][:])/(meteo_j['I0']*surfsolref) #bon
    epsi = 1.-transmi_sol #bon
    ls_epsi = epsi*invar['parip']/(sum(invar['parip'])+10e-15)
    
    graineC, graineN = reserves_graine(invar, ParamP)
    
    
    #calcul de Biomasse tot
    stressHRUE = array(ls_ftswStress['WaterTreshRUE'])
    stressNRUE = array(ls_NNIStress['NTreshRUE'])
    stressFIX = 1-array(invar['Ndfa'])*array(riri.get_lsparami(ParamP, 'NODcost'))#coeff 0.15 = 15% reduction RUE a 100% fixation -> a passer en paarmetre
    invar['RUEactu'] = array(riri.get_lsparami(ParamP, 'RUE')) * stressHRUE * stressNRUE * stressFIX
    invar['PARaPlanteU'] =  array(ls_epsi) * 0.95 * meteo_j['I0']*3600.*24/1000000.*surfsolref #facteur 0.95 pour reflectance / PARa used for calculation
    dM = invar['PARaPlanteU'] * invar['RUEactu'] + graineC
    #dM2 = array(dpar) * array(get_lsparami(ParamP, 'RUE'))
    
    #allocation
    froot = rootalloc(riri.get_lsparami(ParamP,'alloc_root'),invar['MS_aer_cumul'])#fraction aux racines
    for nump in range(nbplantes):
        if invar['germination'][nump]<2:#tout aux racines avant apparition de la premiere feuille
            froot[nump] = 0.99 
    
    invar['remob'] = Cremob(array(dic2vec(nbplantes, invar['DemCp'])), invar['R_DemandC_Shoot'], invar['MS_pivot']) #vraiment marginal
    rac_fine = dM * froot * array(riri.get_lsparami(ParamP, 'frac_rac_fine')) #* filtre_ratio(invar['R_DemandC_Shoot'])
    pivot = dM * froot * (1-array(riri.get_lsparami(ParamP,'frac_rac_fine'))) - invar['remob']
    aer = dM - rac_fine - pivot + invar['remob']
    ffeuil = array(dic2vec(nbplantes, invar['DemCp_lf'])) / (array(dic2vec(nbplantes, invar['DemCp']))+10e-12)#fraction aux feuilles
    feuil = aer * ffeuil
    tige = aer * (1-ffeuil)
    
    
    invar['Mtot'].append(dM.tolist()) 
    invar['Mrac_fine'].append(rac_fine.tolist()) #matrice des delta MSrac fine par date
    invar['Mpivot'].append(pivot.tolist()) #matrice des delta MSpivot par date
    invar['Maerien'].append(aer.tolist()) #matrice des delta MSaerien par date
    invar['Mfeuil'].append(feuil.tolist()) #matrice des delta MSfeuil par date
    invar['MS_pivot'] = map(sum, IOtable.t_list(invar['Mpivot'])) #vecteur des MSpivot cumule au temps t
    invar['MS_aerien'] = map(sum, IOtable.t_list(invar['Maerien'])) #vecteur des MSaerien cumule au temps t
    invar['MS_feuil'] = map(sum, IOtable.t_list(invar['Mfeuil'])) #vecteur des MSfeuil cumule au temps t
    invar['MS_aer_cumul'] += aer
    invar['MS_tot'] = map(sum, IOtable.t_list(invar['Mtot']))
    invar['MS_rac_fine'] = map(sum, IOtable.t_list(invar['Mrac_fine'])) #vecteur des MSraines_fines cumule au temps t
    invar['DiampivMax'] =  sqrt(invar['MS_pivot'] * array(riri.get_lsparami(ParamP, 'DPivot2_coeff')))
    #invar['RLTot'] = array(map(sum, IOtable.t_list(invar['Mrac_fine']))) * array(riri.get_lsparami(ParamP, 'SRL')) #somme de toutes les racinesfines produites par plante
    invar['NBsh'], invar['NBI'] = calcNB_NI(lsApex, seuilcountTige=0.25, seuilNItige=0.25)
    nbsh_2, nb1_2 = calcNB_NI(lsApexAll, seuilcountTige=0.25, seuilNItige=0.25)# recalcul sur tous les axes pour eviter bug des arret de tiges
    for nump in range(nbplantes):
        if nb1_2[nump]>invar['NBI'][nump]:
            invar['NBI'][nump] = nb1_2[nump]
    
    invar['L_Sp'] = array(invar['MS_feuil']) / (array(invar['MS_aerien'])-array(invar['MS_feuil'])+10e-12)
    
    #ajout des bilan C plante pour sorties / m2
    outvar['BilanC_PARa'].append(sum(invar['PARaPlanteU'])/surfsolref) 
    outvar['BilanC_RUE'].append(sum(dM)/sum(invar['PARaPlanteU']))
    outvar['BilanCdMStot'].append(sum(dM)/surfsolref)
    outvar['BilanCdMrac_fine'].append(sum(rac_fine)/surfsolref)
    outvar['BilanCdMpivot'].append(sum(pivot)/surfsolref)
    outvar['BilanCdMaer'].append(sum(aer)/surfsolref)
    outvar['BilanCdMSenFeuil'].append(sum(invar['dMSenFeuil'])/surfsolref)
    outvar['BilanCdMSenTige'].append(sum(invar['dMSenTige'])/surfsolref)
    
    
    #print("MS AERIEN",invar['MS_aerien'],invar['MS_aer_cumul'])
    #print invar['Mtot']     
    
    #for nump in range(nbplantes):
    #    RLProfil[nump] = updateRootLenprofil(invar['RLTot'][nump], RprospectProfil[nump], RLProfil[nump])
    
    #ancien pas base sur enveloppes
    #ls_roots = sol.build_ls_roots_mult(RLProfil, S)
    
    
    # testRL = updateRootDistrib(invar['RLTot'][0], ls_systrac[0], lims_sol)
    #ls_roots = rtd.build_ls_roots_mult(invar['RLTot'], ls_systrac, lims_sol) #ancien calcul base sur SRL fixe
    ls_roots = rtd.build_ls_roots_mult(array(invar['RLTotNet'])*100.+10e-15, ls_systrac, lims_sol)#!*100 pour passer en cm et tester absoption d'azote (normalement m) #a passer apres calcul de longuer de racine!
    
    
    #preparation des entrees eau
    Rain = meteo_j['Precip']
    Irrig = mng_j['Irrig']#['irrig_Rh1N']#R1N = sol_nu
    
    #preparation des entrees azote
    mapN_Rain = 1.*S.m_1[0,:,:] * Rain * par_SN['concrr'] #Nmin de la pluie
    mapN_Irrig = 1.*S.m_1[0,:,:] * Irrig * par_SN['concrr'] #Nmin de l'eau d'irrigation
    mapN_fertNO3 = 1.*S.m_1[0,:,:] * mng_j['FertNO3'] * S.m_vox_surf[0,:,:]/10000. #kg N par voxel
    mapN_fertNH4 = 1.*S.m_1[0,:,:] * mng_j['FertNH4'] * S.m_vox_surf[0,:,:]/10000. #kg N par voxel
    S.updateTsol(meteo_j['Tsol'])#(meteo_j['TmoyDay'])#(meteo_j['Tsol'])# #Tsol forcee comme dans STICS
    
    ls_demandeN = array(invar['DemandN_Tot'])*0.001+1e-15#en kg N.plant-1 #[1e-12]*nbplantes #sera a renseigner -> la, force a zero - devra utiliser invar['DemandN_Tot'] qui est mis a jour + loin #en kg N
    Npc_aer = array(invar['Naerien'])/ (aer+array(invar['MS_aerien']))*100. #Npc avec accroissement de biomasse pour calculer la demande
    Npc_piv = array(invar['Npivot'])/ (pivot+array(invar['MS_pivot']))*100.
    Npc_rac_fine = array(invar['Nrac_fine'])/ (rac_fine+array(invar['MS_rac_fine']))*100.
    
    invar['NreservPiv'] = array(invar['Npivot'])*(Npc_piv - array(riri.get_lsparami(ParamP, 'NminPiv')))/Npc_piv
    invar['NreservPiv'][invar['NreservPiv']<0.] = 0.  #verifier que depasse pas zero!!
    
    
    ls_demandeN_aer = solN.demandeNdefaut2(MSp=array(invar['MS_aerien']),dMSp=aer,Npc=Npc_aer,surfsolref=surfsolref,a=array(riri.get_lsparami(ParamP, 'ADIL')), b1=array(riri.get_lsparami(ParamP, 'BDILi')), b2=array(riri.get_lsparami(ParamP, 'BDIL')))*0.001+1e-15 #en kg N.plant-1
    ls_demandN_piv = solN.demandeNroot(array(invar['MS_pivot']),pivot, Npc_piv, surfsolref, array(riri.get_lsparami(ParamP, 'NoptPiv')))*0.001+1e-15 #en kg N.plant-1
    ls_demandN_rac_fine = solN.demandeNroot(array(invar['MS_rac_fine']),rac_fine, Npc_rac_fine, surfsolref, array(riri.get_lsparami(ParamP, 'NoptFR')))*0.001+1e-15 #en kg N.plant-1
    
    
    
    ls_demandeN_bis = ls_demandeN_aer + ls_demandN_piv + ls_demandN_rac_fine
    fracNaer = ls_demandeN_aer / ls_demandeN_bis 
    fracNpiv = ls_demandN_piv / ls_demandeN_bis
    fracNrac_fine = ls_demandN_rac_fine / ls_demandeN_bis
    
    invar['DemandN_TotAer'] = ls_demandeN_aer
    
    
    #print invar['Maerien']#invar['MS_aerien']
    #print aer
    
    
    #step bilans
    treshEffRoots_ = 10e10#valeur pour forcer a prendre densite effective
    ls_transp, evapo_tot, Drainage, stateEV,  ls_m_transpi, m_evap, ls_ftsw = S.stepWBmc(meteo_j['Et0']*surfsolref, ls_roots, ls_epsi, Rain*surfsolref, Irrig*surfsolref, stateEV, par_SN['ZESX'], leafAlbedo=0.15, U=Uval, b=b_, FTSWThreshold=0.4, treshEffRoots=treshEffRoots_, opt=1)
    S.stepNB(par_SN)
    if opt_residu == 1:#s'ily a des residus
        S.stepResidueMin(par_SN)
        S.stepMicrobioMin(par_SN)
    S.stepNitrif(par_SN)
    ActUpNtot, ls_Act_Nuptake_plt, ls_DQ_N, idmin = S.stepNuptakePlt(par_SN, ParamP, ls_roots, ls_m_transpi, ls_demandeN_bis)
    S.stepNINFILT(mapN_Rain, mapN_Irrig, mapN_fertNO3, mapN_fertNH4, Drainage, opt=1)
    
    
    
    
    if sum(ls_transp)+evapo_tot > meteo_j['Et0']*surfsolref:
        print meteo_j['Et0']*surfsolref,  sum(ls_transp), evapo_tot #Rain*surfsolref, Irrig*surfsolref,
    
    #update des indices de stress hydrique par plante
    p1, p2, p3, p4, p5, p6, p7,p8, p9 = [],[],[], [],[],[],[],[], []#liste de parametres
    for nump in range(nbplantes):
        p1.append(ParamP[nump]['WaterTreshExpSurf'])
        p2.append(ParamP[nump]['WaterTreshDevII'])
        p3.append(ParamP[nump]['WaterTreshDevI'])
        p4.append(ParamP[nump]['WaterTreshFix'])
        p5.append(ParamP[nump]['WaterTreshRUE'])
        p6.append(ParamP[nump]['NTreshRUE'])
        p7.append(ParamP[nump]['NTreshExpSurf'])
        p8.append(ParamP[nump]['NTreshDev'])
        p9.append(ParamP[nump]['NTreshDevII'])
    
    ls_ftswStress = {}
    ls_ftswStress['WaterTreshExpSurf'] = map(FTSW_resp, ls_ftsw, p1)
    ls_ftswStress['WaterTreshDevII'] = map(FTSW_resp, ls_ftsw, p2)
    ls_ftswStress['WaterTreshDevI'] = map(FTSW_resp, ls_ftsw, p3)
    ls_ftswStress['WaterTreshFix'] = map(FTSW_resp, ls_ftsw, p4)
    ls_ftswStress['WaterTreshRUE'] = map(FTSW_resp, ls_ftsw, p5)
    
    #Uptake N et allocation
    invar['Nuptake_sol'] = array(map(sum, ls_Act_Nuptake_plt))*1000 + graineN #g N.plant-1 #test ls_demandeN_bis*1000.#
    try:
        NremobC = invar['remob']*invar['Npc_piv']/100. #remobilise N pivot qui part avec le C
        invar['Naerien'] += invar['Nuptake_sol']*fracNaer + NremobC #uptake N va dans partie aeriennes au prorata des demandes
        invar['Npivot'] += invar['Nuptake_sol']*fracNpiv - NremobC
    except:#1er step
        NremobC = 0.
        invar['Naerien'] += invar['Nuptake_sol']*fracNaer + NremobC
        invar['Npivot'] += invar['Nuptake_sol']*fracNpiv
        print 'rem'
    
    invar['Nrac_fine'] += invar['Nuptake_sol']*fracNrac_fine
    
    #Fixation et allocation
    maxFix = Ndfa_max(invar['TT'], riri.get_lsparami(ParamP, 'DurDevFix')) * array(riri.get_lsparami(ParamP, 'MaxFix'))/1000. * aer #* invar['dTT']
    stressHFix = array(ls_ftswStress['WaterTreshFix']) * maxFix #effet hydrique
    invar['Qfix'] = ActualFix(ls_demandeN_bis*1000., invar['Nuptake_sol'], stressHFix) # g N.plant-1
    invar['Ndfa'] = invar['Qfix']/(invar['Qfix']+invar['Nuptake_sol']+1e-15)
    
    delta_besoinN_aerien = ls_demandeN_aer*1000. - invar['Qfix']*fracNaer - invar['Nuptake_sol']*fracNaer - NremobC #besoin N are sont ils couverts? g N.plant-1
    NremobN = minimum(delta_besoinN_aerien, invar['NreservPiv'])#si pas couvert remobilisation N du pivot directement
    NremobN[NremobN<0.] = 0. #verifie que pas de negatif
    
    #print 'Npivot', invar['Npivot'][0:2]
    #print 'NreservPiv', invar['NreservPiv'][0:2]
    #print 'delta_besoinN', delta_besoinN_aerien[0:2]
    #print 'NremobN', NremobN[0:2]
    
    invar['Naerien'] += invar['Qfix']*fracNaer + NremobN
    invar['Npivot'] += invar['Qfix']*fracNpiv - NremobN
    invar['NreservPiv'] -= NremobN
    invar['Nrac_fine'] += invar['Qfix']*fracNrac_fine #total : vivantes et mortes
    
    #effet feedback N pas fait (priorite) -> necessaire???
    #mise a jour Npc et calcul NNI
    
    invar['Npc_aer'] = array(invar['Naerien'])/ (aer+array(invar['MS_aerien']))*100. #%
    invar['Npc_piv'] = array(invar['Npivot'])/ (pivot+array(invar['MS_pivot']))*100. #%
    invar['Npc_rac_fine'] = array(invar['Nrac_fine'])/ (rac_fine+array(invar['MS_rac_fine']))*100. #%
    
    #print 'Npc_piv', invar['Npc_piv'][0:2]
    
    critN_inst = solN.critN (sum(aer+array(invar['MS_aerien']))/(surfsolref*100.))#azote critique couvert
    invar['NNI'] = invar['Npc_aer'] / critN_inst
    
    
    #update des indices de stress N par plante
    ls_NNIStress = {}
    ls_NNIStress['NTreshRUE'] = map(NNI_resp, invar['NNI'], p6)
    ls_NNIStress['NTreshExpSurf'] = map(NNI_resp, invar['NNI'], p7)
    ls_NNIStress['NTreshDev'] = map(NNI_resp, invar['NNI'], p8)
    ls_NNIStress['NTreshDevII'] = map(NNI_resp, invar['NNI'], p9)
    
    
    #print invar['TT'], Ndfa_max(invar['TT'], riri.get_lsparami(ParamP, 'DurDevFix')), maxFix, stressHFix
    #print invar['TT'], ls_demandeN_bis, invar['Nuptake_sol'], stressHFix
    #print sum(mapN_Rain), sum(mapN_Irrig), sum(mapN_fertNO3), sum(mapN_fertNH4), meteo_j['Tsol']
    #print ls_demandeN_bis, ls_demandeN, Npc_temp, array(map(sum, ls_Act_Nuptake_plt)), invar['Naerien'] #pour convertir en g N
    #print invar['Npc_bis']  
    #print ls_demandeN_bis[0], ls_demandeN
    #print solN.critN(sum(aer+array(invar['MS_aerien']))#, invar['Npc_bis']
    
    
    #calcul offre/demandeC
    tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    #OffCp = calcOffreC (tab, 'plt')#pas utilise??!
    #invar['DemCp'] = calcDemandeC(tab, 'plt')#attention, pour que calcul soit bon, faut le STEPS  suivant mis a jour!-> a faire en StartEach
    #invar['L_Sp'] = calcLeafStemRatio(tab, lsAxes)
    
    #calcul surf par tige
    invar_sc['plt']['Surf'], invar_sc['plt']['SurfVerte'], invar_sc['sh']['Surf'], invar_sc['sh']['SurfVerte'], invar_sc['ax']['Surf'], invar_sc['ax']['SurfVerte'], invar_sc['plt']['PARaF'],  invar_sc['sh']['PARaF'], invar_sc['ax']['PARaF'], invar_sc['ax']['AgePiv'], invar_sc['ax']['MaxPARaF'] = calcSurfLightScales(IOtable.conv_dataframe(IOtable.t_list(lsOrgans)))
    #calcul de fraction de PARa par pivot
    invar_sc['ax']['fPARaPiv'] = rt.calc_daxfPARaPiv(nbplantes, invar_sc['ax']['AgePiv'], invar_sc['plt']['PARaF'], invar_sc['ax']['PARaF'])
    #calcul demande par pivot
    invar_sc['ax']['DemCRac'], invar_sc['ax']['NRac'] = rt.calc_DemandC_roots(ParamP, invar_sc['ax']['AgePiv'], invar['dTTsol'], invar_sc['ax']['QDCmoyRac'])
    
    #calcul biomasse, diametres pivots indivs, QDC des racines, increment de longueur et SRL
    daxPiv = rt.distrib_dM_ax(invar_sc['ax']['fPARaPiv'], pivot, Frac_piv_sem = riri.get_lsparami(ParamP,'Frac_piv_sem'), Frac_piv_loc = riri.get_lsparami(ParamP,'Frac_piv_loc'))#rt.distrib_dM_ax(invar_sc['ax']['fPARaPiv'], pivot)
    invar_sc['ax']['MaxPiv'] = add_dic(daxPiv, invar_sc['ax']['MaxPiv'])
    invar_sc['ax']['DiampivMax'] = rt.calc_DiamPiv(ParamP, invar_sc['ax']['MaxPiv'])
    invar_sc['ax']['OfrCRac'] = rt.distrib_dM_ax(invar_sc['ax']['fPARaPiv'], rac_fine, Frac_piv_sem = riri.get_lsparami(ParamP,'Frac_piv_sem'), Frac_piv_loc = riri.get_lsparami(ParamP,'Frac_piv_loc'))
    invar_sc['ax']['QDCRac'] = rt.calc_QDC_roots(invar_sc['ax']['OfrCRac'], invar_sc['ax']['DemCRac'])
    invar_sc['ax']['QDCmoyRac'] = rt.calc_QDCmoy_roots(invar_sc['ax']['QDCRac'], invar_sc['ax']['QDCmoyRac'], invar_sc['ax']['AgePiv'], invar['dTTsol'])
    invar_sc['ax']['StressHmoyRac'] = rt.calc_StressHmoy_roots(invar_sc['ax']['StressHRac'], invar_sc['ax']['PonderStressHRac'], invar_sc['ax']['StressHmoyRac'], invar_sc['ax']['AgePiv'], invar['dTTsol'])#(dStressH, dPonder, dStressHmoy, dAgePiv, dTT)
    
    invar_sc['ax']['dlRac'] = rt.calc_dLong_roots(ParamP, invar_sc['ax']['NRac'], invar['dTTsol'], invar_sc['ax']['QDCRac'], invar_sc['ax']['StressHRac'], invar_sc['ax']['PonderStressHRac']) #passe STEPS, mais devrait filer les dTT de chaque plante
    invar_sc['ax']['cumlRac'] = add_dic(invar_sc['ax']['dlRac'], invar_sc['ax']['cumlRac'])
    invar['RLen1'], invar['RLen2'], invar['RLen3'], invar['RLentot'] = rt.cumul_plante_Lrac(nbplantes, invar_sc['ax']['cumlRac'])
    dl1, dl2, dl3, dltot = rt.cumul_plante_Lrac(nbplantes, invar_sc['ax']['dlRac']) #calcul des delta de longueur par plante
    invar['dRLen2'].append(dl2)#stocke les dl du jour pour cacalcul senescence de plus tard
    invar['dRLen3'].append(dl3)
    #invar['SRL'] = invar['RLentot']/(invar['MS_rac_fine'][0]+10e-15)
    #print invar_sc['ax']['QDCRac']    
    
    
    #print 'graine', graineC, dltot, invar['Surfcoty'], invar['Mcoty']#
    
    dur2 = (array(riri.get_lsparami(ParamP, 'GDs2')) + array(riri.get_lsparami(ParamP, 'LDs2')))/20. #en jours a 20 degres!
    dur3 = (array(riri.get_lsparami(ParamP, 'GDs3')) + array(riri.get_lsparami(ParamP, 'LDs3')))/20. #en jours a 20 degres!
    invar['dRLenSentot'], invar['dMSenRoot'] = rt.calc_root_senescence(invar['dRLen2'], invar['dRLen3'], dur2, dur3, array(invar['SRL']))
    invar['RLTotNet'] = array(invar['RLTotNet']) + dltot - invar['dRLenSentot']
    invar['MS_rac_fineNet'] = array(invar['MS_rac_fineNet']) + rac_fine - invar['dMSenRoot']
    invar['SRL'] = invar['RLTotNet']/(invar['MS_rac_fineNet'][0]+10e-15)
    
    invar['perteN_rac_fine'] = invar['dMSenRoot']*invar['Npc_rac_fine']/100.
    #sortir une variable cumule d'N des rac mortes? -> compement a invar['Nrac_fine'] qui comprend les deux
    
    #ajout dans la matrice des residus
    for nump in range(len(invar['dMSenRoot'])):
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4+2][voxsol[2]][voxsol[1]][voxsol[0]] += invar['dMSenRoot'][nump]
        #a revoir: tenir compte du groupe_resid
        #tout mis en surface: faire une distrib dans le sol en profondeur!
    
    #ajout des pivots a faire avant mse a jour des cres
    if opt_residu == 1:#option residu activee: mise a jour des cres
        if sum(map(sum, ls_mat_res))>0.:#si de nouveaux residus (ou supeieur a un seuil
          for i in range(len(ls_mat_res)):
              mat_res = ls_mat_res[i]
              if sum(mat_res)>0.:
                  S.mixResMat(mat_res, i, vCC[i])
    
    
    #calcul senesc a faire a l'echelle des axes plutot? -> a priori pas necessaire
    
    
    invar['R_DemandC_Root'] = rt.calc_QDplante(nbplantes, invar_sc['ax']['QDCRac'], invar_sc['ax']['cumlRac'], invar['RLentot'])
    invar['R_DemandC_Shoot'] = aer / (array(dic2vec(nbplantes, invar['DemCp']))+10e-15)
    
    #if '0_0_0' in invar_sc['ax']['NRac'].keys():
    #    print invar_sc['ax']['NRac']['0_0_0']
    #    print invar_sc['ax']['QDCRac']['0_0_0']
    #    print invar_sc['ax']['dlRac']['0_0_0']
    #print invar['RLentot'], invar['MS_rac_fine'], invar['RLentot'][0]/(invar['MS_rac_fine'][0]+0.00000001)

    #calcul demandN -> a depalcer dans le starteach comme pour C?? -> pas utilise actuellement
    if lsApex != []:
        I_I0profilInPlant = cumul_lenIN(lsApex, tab, I_I0profilInPlant)
    
    #pas utilise
    for nump in range(nbplantes):
        invar['DemandN_Feuil'][nump] = sum(I_I0profilLfPlant[nump]*NaClasses)
        invar['DemandN_Pet'][nump] = sum(I_I0profilPetPlant[nump]*NlClasses)
        invar['DemandN_Stem'][nump] = sum(I_I0profilInPlant[nump]*NlinClasses)
        #invar['DemandN_Tot'][nump] = invar['DemandN_Feuil'][nump] + invar['DemandN_Pet'][nump] + invar['DemandN_Stem'][nump]
    
    invar['DemandN_Tot'] = ls_demandeN_bis*1000.
    #print invar['DemandN_Tot'][0], sum(ls_Act_Nuptake_plt[0]), sum(ls_Act_Nuptake_plt[0])/(invar['DemandN_Tot'][0]+10e-12), sum(S.m_NO3)
    
    Npc = (array(invar['DemandN_Feuil']) + array(invar['DemandN_Pet']) + array(invar['DemandN_Stem']))*100./array(invar['MS_aerien'])

    #temps de calcul
    past_time = time.time() - start_time
    
    #sorties
    outvar['TT'].append(['TT',DOY]+invar['TT'])
    outvar['time'].append(['time',DOY]+[past_time]*nbplantes)
    outvar['cutNB'].append(['cutNB',DOY]+[cutNB]*nbplantes)
    outvar['SurfPlante'].append(['SurfPlante',DOY]+map(sum, invar['SurfPlante']))
    outvar['PARaPlante'].append(['PARaPlante',DOY]+invar['PARaPlanteU'].tolist())#append(['PARaPlante',DOY]+invar['parap'].tolist())
    outvar['PARiPlante'].append(['PARiPlante',DOY]+invar['parip'].tolist())
    outvar['epsi'].append(['epsi',DOY]+ls_epsi.tolist())
    outvar['dMSaer'].append(['dMSaer',DOY]+aer.tolist())
    outvar['Hplante'].append(['Hplante',DOY]+invar['Hplante'])
    outvar['Dplante'].append(['Dplante',DOY]+invar['Dplante'])
    outvar['RLTot'].append(['RLTot',DOY]+invar['RLentot'])
    outvar['RDepth'].append(['RDepth',DOY]+invar['RDepth'])
    outvar['MS_aerien'].append(['MSaerien',DOY]+invar['MS_aerien'])
    outvar['MS_feuil'].append(['MSfeuil',DOY]+invar['MS_feuil'])
    outvar['MS_tot'].append(['MStot',DOY]+invar['MS_tot'])
    outvar['countSh'].append(['countSh',DOY]+invar['countSh'])
    outvar['countShExp'].append(['countShExp',DOY]+invar['countShExp'])
    outvar['demandC'].append(['demandC',DOY]+dic2vec(nbplantes, invar['DemCp']))
    outvar['Leaf_Stem'].append(['Leaf_Stem',DOY]+invar['L_Sp'].tolist())
    outvar['NBsh'].append(['NBsh',DOY]+invar['NBsh'])
    outvar['NBI'].append(['NBI',DOY]+invar['NBI'])
    outvar['FTSW'].append(['FTSW',DOY]+ls_ftsw)
    outvar['Etransp'].append(['Etransp',DOY]+ls_transp)
    outvar['DemandN_Feuil'].append(['DemandN_Feuil',DOY]+invar['DemandN_Feuil'])
    outvar['DemandN_Pet'].append(['DemandN_Pet',DOY]+invar['DemandN_Pet'])
    outvar['DemandN_Stem'].append(['DemandN_Stem',DOY]+invar['DemandN_Stem'])
    outvar['DemandN_Tot'].append(['DemandN_Tot',DOY]+invar['DemandN_Tot'].tolist())
    outvar['Npc'].append(['Npc',DOY]+Npc.tolist())
    outvar['NBD1'].append(['NBD1',DOY]+invar['NBD1'])
    outvar['NBB'].append(['NBB',DOY]+invar['NBB'])
    outvar['NBBexp'].append([['NBBexp',DOY]+invar['NBBexp']])
    outvar['R_DemandC_Root'].append(['R_DemandC_Root',DOY]+invar['R_DemandC_Root'])
    outvar['SRL'].append(['SRL',DOY]+invar['SRL'].tolist())
    outvar['DemandN_Tot_Aer'].append(['DemandN_Tot_Aer',DOY]+invar['DemandN_TotAer'].tolist())
    outvar['Naerien'].append(['Naerien',DOY]+invar['Naerien'].tolist())
    outvar['Npc_aer'].append(['Npc_aer',DOY]+invar['Npc_aer'].tolist())#-> ancien Npc_bis
    outvar['Npc_piv'].append(['Npc_piv',DOY]+invar['Npc_piv'].tolist())
    outvar['Npc_rac_fine'].append(['Npc_rac_fine',DOY]+invar['Npc_rac_fine'].tolist())
    outvar['Nuptake_sol'].append(['Nuptake_sol',DOY]+invar['Nuptake_sol'].tolist())
    outvar['NNI'].append(['NNI',DOY]+invar['NNI'].tolist())
    outvar['Ndfa'].append(['Ndfa',DOY]+invar['Ndfa'].tolist())
    outvar['Qfix'].append(['Qfix',DOY]+invar['Qfix'].tolist())
    outvar['dMSenFeuil'].append(['dMSenFeuil',DOY]+invar['dMSenFeuil'])
    outvar['dMSenTige'].append(['dMSenTige',DOY]+invar['dMSenTige'])
    outvar['MS_pivot'].append(['MS_pivot',DOY]+invar['MS_pivot'])
    outvar['MS_rac_fine'].append(['MS_rac_fine',DOY]+invar['MS_rac_fine'])
    outvar['R_DemandC_Shoot'].append(['R_DemandC_Shoot',DOY]+invar['R_DemandC_Shoot'].tolist())
    outvar['RUE'].append(['RUE',DOY]+invar['RUEactu'].tolist())
    outvar['DemCp'].append(['DemCp',DOY]+dic2vec(nbplantes, invar['DemCp']))
    outvar['remob'].append(['remob',DOY]+invar['remob'].tolist())
    outvar['dRLenSentot'].append(['dRLenSentot',DOY]+invar['dRLenSentot'].tolist())
    outvar['dMSenRoot'].append(['dMSenRoot',DOY]+invar['dMSenRoot'].tolist())
    outvar['RLTotNet'].append(['RLTotNet',DOY]+array(invar['RLTotNet']).tolist())
    outvar['MS_rac_fineNet'].append(['MS_rac_fineNet',DOY]+invar['MS_rac_fineNet'].tolist())
    outvar['perteN_rac_fine'].append(['perteN_rac_fine',DOY]+invar['perteN_rac_fine'].tolist())
    outvar['NBphyto'].append(['NBphyto',DOY]+invar['NBphyto'])
    outvar['NBapexAct'].append(['NBapexAct',DOY]+invar['NBapexAct'])#pour correction du nb phyto par rapport au comptage observe
    
    
    #!! ces 4 sorties lucas ne sont pas au format attentdu!
    outvar['phmgPet'].append(['phmgPet',DOY]+map(max, invar['phmgPet']))
    outvar['phmgEntr'].append(['phmgEntr',DOY]+map(max, invar['phmgEntr']))
    outvar['phmgPet_m'].append(['phmgPet_m',DOY]+map(min, invar['phmgPet_m']))
    outvar['phmgEntr_m'].append(['phmgEntr_m',DOY]+map(min, invar['phmgEntr_m']))
    
    #res_root.append(convd(RLProfil[0])) #pour exporter profil de racine (le faire pour tous les systemes?
    
    #HR sol
    #out_HR.append([DOY]+mean(S.HRp(), axis=1)[id_out,0].tolist())
    
    
    #mise a jour variables meteo
    DOY+=1
    meteo_j = IOxls.extract_dataframe(meteo, ['TmoyDay','I0','Et0','Precip','Tsol'], 'DOY', val=DOY)
    mng_j = IOxls.extract_dataframe(mng, ['Coupe','Irrig', 'FertNO3','FertNH4','Hcut'], 'DOY', val=DOY)
    print DOY
    for k in meteo_j.keys(): meteo_j[k]=meteo_j[k][0]
    for k in mng_j.keys(): mng_j[k]=mng_j[k][0]
    
    
    #archivage de lsOrgans
    savelsOrgans.append(lsOrgans)
    
    
    #print invar['germination'], invar['TT']
    #print invar_sc['sh']['Surf'], lsSurfSh
    #print invar['NBBexp'][nump], outvar['NBBexp'][-1][0][nump+2]
    #print invar['lsA']
    #print sum(I_I0profilLfPlant[0]*NaClasses), sum(I_I0profilLfPlant[0]), sum(I_I0profilLfPlant[0]*NaClasses)/sum(I_I0profilLfPlant[0])
    #print sum(I_I0profilPetPlant[0])
    
    #prints et log
    #print epsi, sum3(S.asw_t)  #epsi, map_PI, D,  sum3(ls_roots_eff[0]), sum3(m_frac_evap),sum3(m_frac_transpi),sum3(m_frac_evap)+sum3(m_frac_transpi), sum3(S.asw_t)#, S1#, #, ls_transp, ftsw_tevapo_tot#ftsw_t#
    #print invar_sc['ax']['MaxPARaF']
    #print 'mat_res', map(sum, ls_mat_res)
    #remise a zero de ls_mat_res
    #ls_mat_res = [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#par groupe d'organe et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)# + faire pour chaque groupe_resid (1 seul ici)
    ls_mat_res = []
    for i in range(2):#len(setr)): #force a 2 sinon bug qd des residus de l'esp 1 seulement
        ls_mat_res = ls_mat_res + [0.*S.m_1, 0.*S.m_1, 0.*S.m_1, 0.*S.m_1]#ajout de 4 residus par groupe d'organ et groupe d'especes: feuille(0), tige(1), rac_fine(2), pivot(3)#  pour chaque groupe_resid 
    




def End(lstring,lscene):
    global res_root, outvarpath,outimagepath, savelsOrgans, lsOrgans
    
    #fermeture des bilans -> print cause pb: les sortir en fichier!
    #sys.stdout=open(outBilansTxt,'w')
    S.CloseWbalance(print_=0)
    S.CloseNbalance(print_=0)
    S.CloseCbalance(print_=0)
    #sys.stdout.close() #!! -> fait planter les print en re-run
    #en faire une fonction +  ecriture des disctionnaires en Rdata?  
    
    
    dicout= {}
    dicout['NRain'] = S.bilanN['cumRain']
    dicout['NIrrig'] = S.bilanN['cumIrrig']
    dicout['fertNO3'] = S.bilanN['cumfertNO3']
    dicout['fertNH4'] = S.bilanN['cumfertNH4']
    dicout['HumusNMin'] = S.bilanN['cumMinN']
    if opt_residu == 1:
        dicout['Res1'] = S.bilanN['cumNRes1']
        dicout['Res2'] = S.bilanN['cumNRes2']
        dicout['Res3'] = S.bilanN['cumNRes3']
        dicout['ResidueMinN'] = S.bilanN['cumNRes1']+S.bilanN['cumNRes2']+S.bilanN['cumNRes3']
        for i in range(len(S.bilanN['NminfromNres'])):
            dicout['NminfromNres'+str(i)] = S.bilanN['NminfromNres'][i] #ajout des sorties Nmin par residu
    
    dicout['Lix'] = S.bilanN['cumLix']
    #dicout['N2O'] = S.bilanN['cumN2O']
    dicout['UptPlt'] = map(sum, S.bilanN['cumUptakePlt']) 
    dicout['azomes'] = S.bilanN['azomes']
    #serait a formater dans module sol
    
    #y ajoute les elements du bilan de C plante - mais devrait sortir un fichier separe!
    dicout['PARa'] = outvar['BilanC_PARa']
    dicout['RUE'] = outvar['BilanC_RUE']
    dicout['dMStot'] = outvar['BilanCdMStot']
    dicout['dMSrac'] = outvar['BilanCdMrac_fine']
    dicout['dMSpiv'] = outvar['BilanCdMpivot']
    dicout['dMSaer'] = outvar['BilanCdMaer']
    dicout['dMSenFeuil'] = outvar['BilanCdMSenFeuil']
    dicout['dMSenTige'] = outvar['BilanCdMSenTige']
    
    
    IOtable.write_dict(dicout, path_out, outBilanNfile)
    
    
    
    #ecriture en sortie du profil racinaire
    resrootpath = os.path.join(path_out, resrootfile)#r'H:\devel\grassland\newres.csv'
    f = file (resrootpath, 'w')#r'H:\devel\grassland\newres.csv'
    IOtable.ecriture_csv(res_root, f)
    f.close()
    
    lsorgpath = os.path.join(path_out, lsorgfile)#r'H:\devel\grassland\grassland\L-gume\lsAxes.csv'
    f = file (lsorgpath, 'w')
    IOtable.ecriture_csv_fromlist(savelsOrgans,  f)#savelsOrgans=liste des lsOrgans pour chaque iteration #lsOrgans #lsAxes #lsApex #lsApexStop #ls_systrac[0] 
    f.close()
    
    outvarpath = os.path.join(path_out, outvarfile)#r'H:\devel\grassland\grassland\L-gume\toto.csv'
    ls_keyvar = ['colnames','pattern','TT','time','cutNB','SurfPlante', 'PARaPlante', 'PARiPlante', 'epsi', 'dMSaer', 'Hplante', 'Dplante','RLTot','RDepth','MS_aerien','MS_feuil','MS_tot','countSh','countShExp','demandC','Leaf_Stem','NBsh','NBI','NBD1','NBB','FTSW','Etransp','DemandN_Feuil','DemandN_Pet', 'DemandN_Stem','DemandN_Tot', 'DemandN_Tot_Aer', 'Npc', 'Npc_aer', 'NNI','Ndfa', 'Qfix','Naerien','Nuptake_sol','R_DemandC_Root', 'SRL','dMSenFeuil','dMSenTige', 'MS_pivot', 'MS_rac_fine','R_DemandC_Shoot','RUE','Npc_piv','Npc_rac_fine','dRLenSentot','dMSenRoot','RLTotNet','MS_rac_fineNet','perteN_rac_fine','NBphyto','NBapexAct']#,"phmgEntr","phmgEntr_m","phmgPet","phmgPet_m"]
    IOtable.write_dicttables(outvarpath, outvar, ls_keyvar)
    
    outHRpath = os.path.join(path_out, outHRfile)#r'H:\devel\grassland\grassland\L-gume\outHR.csv'
    f = file (outHRpath, 'w')
    #IOtable.ecriture_csv(out_HR, f)#ls_systrac[0]
    f.close()
    
    #pour gerer la vue de la sortie finale - lucas
    outimagepath = os.path.join(path_out, outimagefile)#r'H:\devel\grassland\grassland\L-gume\scene.bmp'
    #frameDisplay(True)
    #Viewer.display(lscene)
    #Viewer.frameGL.saveImage(outimagepath)
    
    
    #IOtable.write_dict(invar_sc['ax']['PARaF'], r'H:\devel\grassland\grassland\L-gume', 'tot.csv')
    #print sum(m_lais), map(sum, invar['SurfPlante']) ->OK meme surface
    #print cumul_lenIN(lsApex, IOtable.conv_dataframe(IOtable.t_list(lsOrgans)), I_I0profilInPlant)#lsApex
    #tab = IOtable.conv_dataframe(IOtable.t_list(lsOrgans))
    #print calcSurfScale(tab, 'sh')
    pass


#verif effet lumiere?? OK
#introuire modulation incli par PARt? Fait, mais a ameliorer (elasticite nouveaux noeuds f(par apex) + modulation incli (f par SHP)
#introduire TT et phyllochrone OK (meme vitesse que density visu)
#introduire feuille:


#passer phyllotaxie en parametre (gere par apex)OK
# verifier les angles feuilles...OK
#introduire statut feuille: exp/mat/sen/mrt (differentes interpretation) #survie dependence a par

#gerer TT_omb et senescence induite par rayonnement OK
# / pos au niveau des feuiles pour lumiere / reponse coupe (trefle) OK
# calcul PARa feuille /calcul PARa plante/ dM : visu+(unite MJ!) OK
#vitesse developpement racine f(PARa) OK
#introduire pool commun + frac_racines / allocation racines OK pour masse de pivot/racine fines
#gerer PARaplante (total, liste, distrib?) -> OK liste (PARaPlante)+ une variable somme (dpar)
#(couleur/transparance des II fonction de deniste de longueur racinaire)#pas fait
#calcul densite de longueur total + profil densite par horizon (f des rayons -> stocker en global les rayons par horizon?) OK RLProfil
#couplage sol / bilan hydrique #OK 
#Verifier que Q1 =  Q0 + PI - EV -T - D: OK (plus debug bilan hydrique)



## ajout de numero de plantes dans les modules (supprime nump global)->OK
## declaration description des modules (declaration et simplification des parametres (Lfeuille...)->OK
## posi -> gerer avec Collet ou pas? -> OK




## test de plusieurs plantes en meme temps en competition
# passage de parametre differents a differentes plantes/genotypes en competition -> OK
# distinguer les dpar/PARaPlante/SurfPlante par plante ->OK
# bug? -> development racinaire tjrs identique??? PARaPlante identique?->OK [[]]*n effectue pas une deepcopy; initialise avec for
# passer SurfPlante en profil -> OK
# donner en entree un equivalent du .8 (limite scene/motif infini) -> OK
# pattern8 sert a instancier l'objet sol  -> a partir de ses dimensions -> reserve utile... ->OK

# faire LAIprofil comme somme des plantes, puis rapporte par unite de durface du .8 -> OK
# en deduire profil de LAI -> OK
# debrancher LAIvois pour effet de competition -> OK

#calculs d'epsi par plante? -> OK toutefois!!! bilan radiatif boucle pas exact!
#!! approximation bilan radiatif : somme des PARaPlante+transmis sol -> different de incident, notamment du fait de prendre une valeur unique de rayonnement par horizon pour ttes les feuilles; faudrait revoir ce calcul


#individualisation par plante du fonctionnement du modele sol

#!! pb de ASW??? avec petit pattern8 devient negative quasi immeidatement sans demande particuliere??? dans les horizons de evap; comme si evap pas de scale en fonction du pattern? amelioration module sol? ->OK solutionne en multipliant Et0 et Precip par surfsolref
#modif: dM, Mrac_fine, Mpivot, avec nump ->OK
#profil densite par horizon par plante: Rltot, RLprofil, RprospectProfil avec nump -> OK
#ls_roots et fonction build_ls_roots de soil_module2 ->OK build_ls_roots_mult
#connection des ls_roots et ls_epsi pour distinction plante a plante dans le couplage lumiere/eau ->OK
#partage d'eau + recup FTSW par plante -> OK ls_FTSW


#change fichier

#une fonction de reponse a ftsw -> OK
#reponse RLAP a FTSW local (retrocontrol humidite locale sur dev des racines / plante) -> OK
#lire dans precips et faire regine pas constant -> OK
#reponse croissance tige a etat hydrique plante global (FTSWplante) ->OK
#de plus calcul refait a chaque noeux (stoquer effet etat hydrique par plante plutot que etat hydrique pour eviter de refaire calcul)-> OK ls_ftswStress
#tige OK mais changemet de taile instantane et pas conserve qd eau revient... faudrait l+dl -> OK et en + ajoute statut a In() pour eviter calcul d'expansion indefini (deja le cas pour les feuilles)
#reponse croissance feuille a etat hydrique plante global (FTSWplante) ->OK, mais comme feuille apparaissent > 50% taille finale, voit pas d'effet!! (change developpement des phytomeres (delaiF comme pour mimer inititation) ; Rq: semble favoriser le petit geno dans la competition sans stres???
#caluls taille de feuille sur la base d'un param ratio retirer (remplace par calculs base sur l) / simplifie organisation du module feuille -> OK 



#effet sur le developpement :modulation phyllochron tige (sinon accululation de bourgeon bleus sur plante qui pousse pas!) -> OK mais a tester + a fond (notamment compatibilite avec le modulo)


#effet sur le developpement (apex racine primaire...)-> a faire

#demo mircro peuplement FSPM a faire


# introduire gradient de taille potentielle d'organes -> OK pour tige et OK pour feuille 
# pris en compte dans calcul des surfaces! + retirer parametre largeur? OK
#calcul de taille reel faits dans interpretation et pas dans production -> OK intro des calculs de profils dans Start
# moduler elasticite par longueur des en! ->OK (*Len)/change module en et g['elvtresh'] (qui depend de elasticite)
#orientation azi feuilles toutes identiques (pas phyllotaxie) -> OK + ajoute regulation elongation petiol 
# voir si peut limiter les calcul pour angle porteur? test trefle 
# version par default avec IncPet fixe le fait deja! -> pas besoin de calcul et de vecteur du GetUp normalement
# Y a des pb de gestion des incli ini qui change brusquement pour des plantes rampantes??? -> OK passe elv0 en parametres
# faire senescer les petioles pour limiter le nb de modules garde dans la chaine sous la zone de coupe -> OK, auvec duree de vie max des feuilles

#Rq: en trefle rampant: des vagues de senescence soudaines (lie a ttes les feuilles dans la meme strate et passe le seuil lie au rayonnement probablement...) a solutionner


# introduire ramification secondaire + r?nse PAR  (type tiago)->OK
# -> ajoute des bourgeons dormand (ordre 2 ?'aisselle des feuille I) D2(); specifique qui recuperera aussi le rang / rang porteur...#cree apex A2()
#ralenti considerablement temps de simul 15s -> 45s! *3
# introduire un parametre d'activation/desactivation des ramifs secondaires->OK
#taille des noed repart de 1 ; taille des feuillesII repart de 1+ rang du porteur + facteur cor_ramif a utilise->OK
#gerer une duree de vie de ces bourgeons/apex si ombre...-OK, 
# introduire reponse du developpement specifique des ramifs au deficit hydrique par exemple (plus sensible au niveau du developpement) #sortir parametre en dur de FTSW_resp(FTSW) ; en avoir pour primaire et secondaire ->OK
#remplacer ls_ftswStress unique -> pour tenir compte des reponses differenciees des processus->OK
#Rq: aerien est fonction de ftsw plante; croissance racinesII fonction de sol local (horizon)

# gerer debourement selon un delai (sylleptique) ou selon disparition de la dominance de l'axe principal (coupe)-> a faire
# y a sans doute pb dans gestion des arret d'apex...

#Faire des test de densite (plante seule) / avec et sans deficit hydrique


#test type trefle rampant -> qqs pb de geometrie dans orientation des ramifs a resoudre ->OK
#racines adventives -> introduction de bourgeon racinaire RB a l'aisselle des bourgeon axilaire OK
#disparaissent si touche pas le sol et/ou proba de tirage pas respectee ->OK
#statut pour tester etat hydrique sur une periode: RB avec dormant / actif en attente ou etat hydrique teste sur une periode->OK
#garder le rang du porteur en parametre RB (recherche de lien avec les ramifs? tjrs active?) pour maintenir racine adventives en croissance -> a faire
#'ProbaMaxAdvRoots' pourrait etre remplacer par info sur env local (branch en croissance? et devenir deterministe?)
#de maniere generale, relation trophique pour gerer l'arret des racines adventives -> a faire (demande en C prevue pour 1 systeme racinaire unique??)
# ratio et ParamP[nump]['ombR_Ltresh_max'] qui gerent RA a revoir en fonction de demande de tous les sous-systemes racinaires
# + faire bilan offre demande en C et verifier qu'est ce qu'on peut allouer-> a faire!
# en consequence racine adventives poussent probablement trop dans cas actuel


#passer caracteristiques RUE et racines (SRL...) en parametres -> OK ; utilise une fonction get_lsparami(ParamP, param) pour faire liste des param par plante
#ajouter parametres pour gerer diametre pivot/collet et -> OK, mais remonter les calculs hors de RS ->OK
#faire varier largeur du pivot en fonction de profondeur -> OK #reduc lieaire de diametr jusqu'a ZPivot_min
#gerer la zone de depart des bourgeons primaires en fonction de largeur max du pivot-> fait dependre le posi de D()/B() dudiametre du pivot->0K(rayon+0.5cm)

#introduire rhizome / prospection sous-teraine
#modficatin des comportemnts des B() et des D() ; D() passnt neessairement par B()
#B() fait les noeud de rhizomes avant de prouire A() ->OK
#rhizome suppoe avec In slmt ; nb noeud tirre a la creation du bourgeon dans une loi binomiale
#passe le @M a l'initiation des B() et plus a SHP ->OK
#passe paametre de positionemenent (? azi en particulier) a bourgeon vB() ->OK.
#azi tige et azi rhizome identiques -> suppose dans le prolongement ; ?Remetrre un random sur azi des tiges en bout de rhizome (tendance a faire plantes creuses?) 
#bourgeon dormant cree au niveau du pivot et pas de la tige ou sur rhizome -> a voir si coherent ; en particulier pour autres especes ; Pourrait mettre une proba qui remet nouveau bourgeon sur la couronne ou repartir de tige precedente? -> a faire
#certaines des interpretation de SHP  (azi, incli 90) faite en amont->OK
# regles d'interpretation effectuee a creation du bourgeon -> a changer: introduire comme SHP et interpretation separee? noeud au lieu de F?

#faudra attriuer un cout a cette colonisation par rhizome -> a faire
# en fait actuellement Deja un cout associe -> retard de developpement des tiges feuillees (devrait etre balance par levee des bourgeons D() pas slmt par la coupe!) 



#lecture des parametres dans un fichier excel
# par convention parametres 1 valeur ou une liste de valeur -> change profilLeafI (liste de liste) en profilLeafI_Rlen/profilLeafI_Rlarg ->OK
# rajoute une liste de paramettre 'Tdev': pour gerer developpement: dTT et calcul de STEPS; defini pour chaque geno, mais STEPS calcule uniquement sur 1ere plante (nump=0) donc suppose que ce parametre ne change pas entre plantes d'une meme scene!
# faudrait adapter: avoir un vecteur de TT (qui contient des TT par plante) et un pas de temps modele (steps) cale sur une des plante (e.g. nump=0) ! a bien gerer les %STEPS!! -> a faire
# modifier le parametre par_tresh qui gere arret/depart de developpement: seuil de rayonnement d'absolu passe en relatif de I0 (coherent avec les relations fonctionnelles) -> recalcule a chaque jour -> OK
# retire PP (photoperiode) du calcul qatot et PARaF -> I0 suppose moyen sur 24h -> OK
# revoir les unite d'entree du rayonnement (MJ au lieu de W.m-2?) -> adapter les calculs -> a faire
# reprend lecture parametre luca dans read_plant_param() dans IOxls et test sur un g4 equivalent a g1 ->OK


#prepas propre des sortie dans un dico puis ecriture a end
#passe 'Coupe' par fichier meteo et supprime TTcutFreq ->OK
#cree un dico de sortie outvar (/sortdico lucas -> pb de global qd mis a jour? + indentation)
#tester avec 'SurfPlante' et 'PARaPlante' -> supprime et remplace M_SurfPlante' 'M_PARaPlante -> OK
#Sorties a prevoir: Surf/MStot et autres/ Hmax/Dmax/Root Depth... OK
#pour les Hmax -> faire eval par plante (pas HmaxCouv) -> OK
#rq: Hmaxcouv et updateLAIprofil plus utilise -> les retire -> OK
#Hpalnte lucas -> evaluer sur les apex -> collera pas toujours, faire aussi sur petioles/feuille -> OK

# calcul de PARaPlante sur feuille verte uniqument / ls_epsi sur feuille verte uniquement
#-> perte du rayonnement intercepte par feuille jaunes? -> a revoir/a faire car raboute pas et dM bizarres qui baissent en fin de repousse!
#test avec PARiPlante -> ajout du PAR des feuilles senescentes change pas grand chose au cumul -> OJ mais pattern avec chute reste? lie a taille des feuilles plus bas en haut de tige?
#comparer I0*espi des differentes strtaes et somme des PARa feuilles dans une strates -> pas sur que valeur affectee soit la bonne !! -> d'ou ce pb?? -> en fait somme de PAR min par strate marche pas -> seulement approcimatif
#l'utilise pour caluler des epsi en absence de vrai bilan radiatif (caribu), puis calcul dM sur base de epi*incident -> OK
#rq: dpar et ls_parap identiques -> simplifier! -> OK -> parap 

#Faire inventaire des variables plante instantanees utilisees dans les calculs
#dico invar -> test avec SurfPlante, PARaPlante, PARiPlante -> OK; doit pouvoir retirer variable SurfPlante -> OK
#continuer pour Hplante... -> OK pour variables integrees plante


#adapter des sorties pour les variables de profil, couvert et par plante LAI et deniste racinaire -> en reflexion, a faire
# aussi pour ls_ftswStress


#calcul et sortie d'un TT par plante (garde step bas?rbitrairement sur un id a fournir)?? -> un vecteur vTT cree, mais utilisation a faire


#chek limitation trophique par axe pour arreter les expansion / assurer la conservation de masseD(
# commencer par faire un inventaire des axes en croissance (jusqu'a ordre 2) par plante -> tenir a jour une table
#commence avec lsAxes
# pb-> module porte le nump mais pas leur numero d'axe -> a reporter! (nsh des modules B() qui sort pas de B())
# pb -> nsh de B() plafonne a  nshoots+1 -> plein de fois le meme nsh -> tenir a jour un compteur de tige par plante! 'countSh' -> OK
# a reporter aux autres modles -> fait pour aerien OK
# recup axes jusqu'a ordre 2 ; lsOrgans -> bizare -> rang des feuilles 2 sans doute pas bon + bcp de tiges (bcp plus qu'avec apex slmet->tige coupee qui apparissent) !!? distinction de rank et rankp pour les Lf() et In() pour garder topologie jusqu'au bout -> OK
#ecrit fonction offre et demande qui calculent le delaMS ofert par PARa et le delta demande max demande pour expansion des tissus aeriens a differentes echelles - base sur la table d'info par organe (ici construitr, mais pourrait resulter d'interrogation du MTG)
#-> OK pour les fonction offre(t-1) et demande (t)
#pb pour appeler demand -> devrait etre fait dans le starteach -> quelle initialisation (demande mini si pas d'oragne en exp?)?
#reserve initiale (graine) a ajoute??? Quel mecanisme de mise en reserve?


#calcul du feuille:tige ratio sur la base des tige avec apex en activite et SLAmin et SNLmin -> OK, mais resutat mediocre, sauf a la 1ere pousse; leaf:stem au gmente au cours de la croissance au lieu de diminuer...?? cause (tige de crown?)?? -> a creuser 
#-> MS des tiges augmente plus vite que MS des feuilles au debut des repousses + grosse discontinuit?u premier step suivant?? (en 1 step equivalent de 0->17cm)  - probablement lie a des tiges en attente qui repassent actives + comme ont deja 2-3 noeud, partent tout de suite avec des en longs (alors que max des feuilles plus tard...) -> pb assez structurel
#verif feuille/tige au niveau d'un phytomere


# calculer un Q/D? que mettre en reserve?
# pas de feedback implemente... necessaire ou pas au vu des Q/D? -> tester dans une autre version
# 

#rajoute comtage de tige 'significatives' et comptage des NI sur les tiges les mieux developpes : NBsh et NBI -> OK

#couplage avec donnees competiluz OK ; probablement une erreur dans les rayonnement (global, versus RUE PAR + production de racines la dessus)
# temps de calcul pour un 'G1' -> 163s pour 1 an (142s sans visu) #200/300s pour C1 , 1100s pour 7plantes en dense (G3)
# a faire -> facteur correctif de forme des folioles virtuels pour avoir les bonnes surfaces!

#C1 -> un peu en dessous en biomasse
#G1 -> bien, mais semble faire trop de tiges A2 (peu de tiges qui ramifie bcp)
#G3 -> port semble pas assez redress?


#Adaptation stage lucas
# intro coeff allometrie d'adaptation des surface ?on/larg reel -> OK 'leafshape'/'stipshape', introduits pour les calcul de profils potentiels
# intro param sigmo par organe -> ok
# intro geometrie stipule -> ok -> organe supplementaire ajoute au phytomere qui est d?uit (->*)si param taille =0
# geometrie stipule suppose meme incli que feuille/longueur dans direction du petiole
# intro geometrie feuille n folioles > 3 + profil de nb de folioles (pour cas sainfoin)-> OK # n folioles disposes sur un arc de cercle
# a faire: gerer continuite avec le petiol a faire / n foliole d'une repousse repart de 3 comme pour une graine, sans doute pas bon
# rq comment distribuer surface foliaire entre voxels pour grandes feuilles?
# rq2: stipule et /ou nbfolioles (surtout!) augmentent considerablement le temps de simul (preque double)
# surface de stipule et nfoliole reportee dans surface plante/profil/interception de PAR! -> OK
# distinguer 3 types de tiges type1, type2 et M (= tige s?nale de la graine)
# type M correspond en fait a nsh=0; -> suppose developpement et profils pareil que autres primaires except?our longueur d'en
# -> introduit parametre ratioM et calcul cor_M pour corriger en de l'axe I de la tige seminale si besoin (eg Trefle)
#dans cas de la luzerne M=type2, mais pas pour trefle



# calcul de rayonnement sur une grille et plus en 1D (meme si seulement vertical) -> definir grille et remplir des voxels!!
#construction grille m_lais -> OK -> predefini taille des voxel sur la base du .8 avec dx=dy=2*dz
# nbr grilles minimis?nb de distrib d'angle different g? par 'gammagroup' (1 par espece/ou distrib d'angle differente?) -> OK
#remplissage des surfaces par entite -> OK
# toutefois -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (elongation noeud?)
# calcul des k_teta dans le start -> ls_dif OK ; (a reprendre si possible en python, pour le moment fonction r)
# calcul bilan radiatif et partage entre entite -> OK 
# temps d'exectuion pas affecte par creation grille et affectation des surfaces
# calculde bilan radiatif sur les voxel augmente legerement temps de calculs 
#(2s en plus sur 80j pour 3*3*18 grid)
# 1 plante sans ramif passe de 6.5 a 8.5s
# 7 plantes avec ramif passe de 99s a 101s
#(9s en plus sur 80j pour 5*5*29 grid)
# 1 plante sans ramif passe 7s/16s
# 7 plantes avec ramif passe de 99/108s 
#rq: complexite du couvert joue du coup pas trop sur le temps de calcul


# caller les surface et calculs d'interception entre t et t+1 -> OK
# un m_lai_construct pour garder m_lai du tour d'avant en memoire d'un pas sur l'autre

# verif PARaF_bis unit si ok; -> comparer avc PARaf! rq: PARif_bis integre deja la surface
# -> #check dans PARaPlanteBIS -> OK, tres bien relie en isole

#test en 7 plantes -> voit pas de differences sur plante du milieu -> differences entre plante refletent difference de surface
#-> test en micropeuplement plus complexe/grille + fine?
# + adapter fonction de calcul des surfaces au stipules->OK

# sol/voxel pas pris en compte pour corriger I0? -> verif si OK? -> non sinon pas Lai
# m_lais sont en fait des cumuls de surface! -> utilise m_lais/surf_refVOX pour des lai vrai
# ajoute un *surf_refVOX au rayonnement invident de chaque voxel
# ds ce cas retombe bien sur bon ordre de grandeur ->OK
#? calc_PARprofil(LAIprofil, meteo_j['I0'], k) #manquait'il un *surfsolref au niveau de meteo_j['I0'] dans versions anterieure? eviterait *surfsolref ds qatot

# verif avec un ring supplementaire? -> OK plante du centre plus ombree et exterieure moins ombree
# verif avec plusieurs entite -> OK, bug pas + incli plus forte capte moins (mais difference cependant tres faible 
# gerer cas si veut 1D vertical -> verif que donne bien la meme chose -> OK marche bien
# rajoute outvar['time'] pour recuperer les temps de calcul


# ajouter une sortie temps a chaque step (comparaison des temps de calculs)->OK 'time'
# entreprendre le remplacement des PARprofil[strate] -> faudra gerer les transmis et surf_refVOX (car intensite plus faibles??)
# remplacement au niveau des apexs -> OK! -> reponses morpho locales!
# -> semble reduire developpement et accentue asymetrie de competition entre plantes (apparition d'alternances)
# arret des apexs semble parfois precoces?? -> relever les seuils ?? -> a evaluer/quantifier

# a faire -> faire switch complet au niveau des feuilles et PARa 
# dans un premier temps inverser PARa et PARaBIS->OK
# debrancher partout sauf qatot, ls_epsi -> a reprendre/adapter->OK c'est fait
# dans B() et SHP! aussi -> OK fait
# puis debrancher / retirer PARprofil; retirer PARaBis -> OK, fait + retirer la visu d'un turbid aerien / LAIprofil_cum (utilise par le turbid) et PARprofil; garde en revanche SurfProfilPlant

# couplage pour transpiration sol : reste le m? (somme de ce qui arrive au sol / epsi global) -> peut etre adapte a grille de sol de meme dimension

# faudra minimiser la taille des grille (hauteur = f(t) avec secutite, mais pas fixe
# faudra tester versus caribu dans une version 24bis (TP lucas)

# ajoute sortie des FTSW plante et transpiration par plante ->OK

#H0 demande N: light climate drives N demand!
#au niveau des feuilles
# 2 options envisageables pour distrib de I/I0 et N par plante -> repartir sur les voxels (via dico et liste de cles) ou un vecteur predefini de classe I_I0 entre 0 et 1 -> teste la seconde en premier avec I_I0profilLfPlant
# distrution des surfaces ok:  sum(I_I0profilLfPlant[0]), sum(invar['SurfPlante'][0]) donnent bien la meme chose
#pour petiole, peut faire des cumul de longueur par classe d'eclairement
# passer le getpos feuille dans regle de production des petioles-> OK
#utilise meme relation N par unite longueur en fonction de I_I0 pour petiole et tiges
#differe par I_I0 -> apex pour les tiges/feuilles pour les petioles


#comment gerer N a la coupe: ce qui reste et ce qui part? ->faire porter aux feuilles une info Na?
#DemandN des tiges/petiole a faire -> par axes avoir les longueur et les apex les mieux eclaires!
# fait pour petiole -> OK
# pour tiges a patir de ls_apex (donnes les tiges actives+leur PAR) + ls_ActiveAxes (qui donne les longueur de tous les noeuds) ->OK
# remplir un profil par plante : longueur par classe de I_I0 -> comme pour feuilles et petioles

#calcul d'un %N (Npc)  au niveau aerien
#pb -> tendance pas bonne du tout (augmente!!) notamment car MSaerien pas bon -> masse residuelle apres coupe due a decalalge dans dMSaerien et MSaerien -> a corrigier


#v28
#corrige un bug dans les largeur de feuille (max des deux fonctions, pas min) -> revoir parametrage
#corrige un garde-fou profondeur d'enracinement avec 'prof_sol_max'
#corrige bug I_I0 des apex (certains I_I0<0) : erreur de paranthese dans le modulo!
#corrige bug calcDemandeC pour les feuilles (calculait pas bien le delta de surface) et les noeuds (erreur sur seminale)
#ajout dans calcDemandeC de la demande des petioles (introduit paramtre 'SPLmin') et des stipules
#introduit fonctions calc_Lpet et calc_Lent pour les calculs de longueur d'entre noeud et petiole
#renome lsActiveAxes en lsOrgans et y ajoute les Pet (pour demande en C)
#ajoute un compteur de temps a l'ombre 'duromb' pour apex primaire A
#ajoute sortie d'une liste d'apex a l'arret lsApexStop
#modif dans cumul_lenIN pour pas bugger qd champ supplementaires dans lsApex
#ajoute un argument 'parent' =nsh du B() au D() 
#ajoute un argument 'statut' du B(): 2 types de B(): exp (qui peut avoir developpement exp sous condition et regular (simple trace du bourgeon pour la repousse suivante apres coupe)
#simplifie nsh = donne directement a creation du B ou D; ajoute un argument nsh au D
#ajoute lsApexMort dans invar 
#ajoute NBD1 et NBB dans invar et les sortie: nb de bourgeons dormants (D) et actifs (B)
#introduit dominance apicale pour debourrement des D() -> part seulement quand parent n'est plus dans la liste des tiges (coupe)
#introduit critere de mort des A() -> si tige n'a plus des surface du a senecence
#introduit mort des D() si A() parent mort
#ajoute un %age au depart du D() pour avoit petits decalages
#introduit parametre NBexp qui donne le nb d'axes generateur B (-> controlle vitesse de tallage)
#pour garder potentiel de redemarrage: reguler les B(exp) meme apres que le nombre max de D() soit atteint
#passe par outvar[-1] pour garder memoire du coup d'avant -> a l'air de fonctionner
#fait mourir En, Pet, A2 et D2 des tiges mortes
#fait un dico  par echelle 'invar_sc' des surface, surface verte, PARa cumules (servira pour racines adventives trefle)
#-> invar_sc['sh']['Surf'] remplace lsSurfSh
#parametre NBexp marche pas comme attendu si teste en B: nb de bourgeons augmente uniquement apres coupe et levee de dormance de D
## basuler en D a la regle de creation de de type exp a la place de D 


#v29
# coupler soil_module 3 a la place du 2 ->OK
# test trefle: 
# TB: certaines tiges remontent a 45 degre!! -> les secondaire de la tige 0
# pas lie a densite, ni a active elvtresh  + sans ramif (Active branch=0), pb disparait
# ok: ajoute un 'SetHead()/(azi)&(90)' comme pour les autre B() au B() produit dans la graine
# certains axes avec des stipules au bout!!?? -> Normal car Stp() systematiquement produit, puis detruit;  Mettre longueur de stipule 'Lstip' a zero pour pas l'avoir
# 

#+axes meurent systematiquement a forte densote -> lilite LAI vers 2! question de quel organe percoit pour mort des tiges -> feuilles au lieu des apexs?
# pb be feuilles mal orientee sur la tige 0 apparemment maintenant???




#V30: modif du systeme racinaire: introduction de tropisme des racines II + impact sur densite
# cacul d'une trahectoire profilRoot par plante dans le Start() en fonction de 2 parametres: g_root et IncRoot0 -> utilise par la suite pour definir enveloppe en fonction de longueur
# modifie interpretation de RLAP -> recalcul forme du cyclindre a partir de ParamP[nump]['profilRoot']
# redistribution des densite de longueur par horizon -> import d'un modul RootDistrib qui peut gerer compet en 3D
# ajout de ls_systrac = dictionnaire par plante de liste de cylindre composant un systeme racinaire
# empecher croissance en dessous de fin du profil pour ces secondaires -> OK
# ajout d'un cylindre pour RA (racine primaire) -> OK
# test de couplage avec bilan hydrique -> OK
# tester avec plusieurs plantes -> OK / temps de calculs augmente de 10 a 20pour cent...

#V30b: reprise racine adventive trefle et limitation des diam par sous systeme aerien!
# adapter largeur pivot + faire dependre dispo locale en PARa!
# ajoute dans invar 'R_DemandC_Root' -> pour stocker satisfaction de croissance globale des racines
# ajoute arguments nsh, et rank a RB() et RA() et RS()
# ajoute 'Piv' a lsOrgans (cree a partir des RA() -> permet d'avoir une liste des pivots et leur position topologique
# ajoute fonction calc_daxfPARaPiv qui attribue un PARa a chaque pivot -> stoque dans invar_sc['ax']['fPARaPiv']
# calcule une MS cumulee distribuee entre les differents pivots: invar_sc['ax']['MaxPiv'] avec fonction distrib_dM_ax()
# calcule un dictionnaire des diametres invar_sc['ax']['DiampivMax'] avec fonction calc_DiamPiv()
# lecture des bons diametres dans RS()

#V30c: 
# ajout d'un age cumule a RA() -> pour calcul developpement potentiel des sous systemes racinaires ->OK
# import nouveau fichier parametre plante V3 -> OK
# import d'un module racine potentiel derive de Pages / archisimple + ameliorer nomenclature des import import... as ... -> OK 
# calcul d'une demande de C par sous systeme racinaire -> OK, invar_sc['ax']['DemCRac']
# calcul d'une offre locale en C pour croissance des sous systm racinaires -> OK, invar_sc['ax']['OfrCRac']
# ajout nsh, rankp pour topologie dans RLB, RLAP -> OK
# calul d'un ratio Q/D + limitation locale de l'expansion des enveloppes en fonction de QDrac instantane -> OK
# peut tester ancienne et nouvelle version d'enveloppe avec commentaire sur les ratios...

#V30d: 
# fichier externe et y mettre les fonction de croissance du pivot -> OK
# pour calcul des longueur effectives -> faut integre effet des stress hydrique sur les longueur, pas juste C -> ajout d'un stress hydrique moyen par pivot (integre horizons par horizon en fonction de longueur et dans le temps en fonction des steps) : fonction calc_StressHmoy_roots ->OK
# rq pour le moment juste RLAP depend dus tress hydrique, pas RA()?
# prise en compte de stress hydrique passe pour determine demande en C
# calcul de delta de longueur par classe sur la base de Vrac, N apex, Hstress (inst), Cstress(inst) -> fonction calc_dLong_roots, invar_sc['ax']['dlRac'] -> OK mais des dl qui deviennent immenses???? au bout d'un temps par racine primaire???
#preparer les sorties de longueur tot de racine par plante + SRL moyen (ratio longueur / biomasse rac fine) -> OK

# coupler les densite de longueur a la place de SRL fixe dans calcul de ls_roots -> OK, mais faudra passer calcul de ls_roots et bilan hydrique APRES les calcul de longueur (la decalage de 1 step du coup dans les densite utilisee...)
# 1er tests avec parametrage luzerne et TB donnent differences de SRL coherentes entre les deux especes (30-50 vesus 150-400 m.g-1)

#V30e
# faire depndre vitesse des bons parametres !-> OK,  'Relongation_durationI', 'Relongation_durationII', 'Relongation_duration0', 'delai_RLAP' passe dans l'update des parametres root
# debranche ancien calculs de ratio C racine ->OK
# retirer les RprospectProfil ->OK, tout passe en commentaire
# retirer DiampivMax de invar -> seulement dans invar_sc['ax']
# 'R_DemandC_Root'-> recalcul avec fonction calc_QDplante -> OK
# rq: QD tu TB tres faible (resulte vraisemblablement de beaucoup de sous systemes arrets)
# fichier des parametres pour toutes les especes mis a jour ->OK / reste cependant a retirer ancien parametres racines du fichier param 3 qui ne servent plus (surlignes dans giga)
#verif temps de calcul sur couvert luzerne -> pas modifie par rapport a juste modif des enveloppes
#comparer les cartes de densite sur TB et Luz -> OK


#V31 : reponse de developpement des axes a max(PAR apex, PAR feuille axe)
# ajout de invar_sc['ax']['MaxPARaF'] -> calcule dans calcSurfLightScales -> OK
# test comparaison des PAR apex, PAR feuille axe en forte densite -> bug??? Nan pour l de RLAP??
# lie a ratioC calcule avec rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax)
# pb deja dans invar_sc['ax']['QDCRac']: {'0_0_0': nan, '0_1_1': nan, '0_0_2': nan}
# deja dans invar_sc['ax']['OfrCRac']
# deja dans invar_sc['ax']['fPARaPiv'] -> dont les differentes entrees sont OK?
# pb vraissemblement dans rt.calc_daxfPARaPiv -> ok 'ajoute epsilon pour eviter division par zero)
# apex A sensible PARsense -> change pas grand chose car c'est feuilles qui senesce qui font mourir tige
# curieux que toutes les feuilles senesce en meme temps dans TB?

# change pas grand chose au crash de TB a forte densite: PAR feuille faible (toutes dans meme srtate)
# test effet de dz_aerien (precision dicretisation) / ombF_Ttresh sur senescence des feuilles
# pour les couverts de TB: faire des Hmax plus faible et des dz plus faible aussi

# -> impact enorme senescence des feuilles a l'ombre: ombF_Ttresh eleve font disparaitre mort des axes I, mais comportement atypique des axes secondaires menant a des LAI tres eleves
# parametre MaxSurvOmbr des A2 a ajuster (long pour) (baisse pour TB pour arreter rapidement les secondaires?
# + D2 -> A2 pas reguler par la lumiere = systematique (seul arret est regule) : jouer sur proba de ramif qui reste trop elevee?
#reponse photomorpho pour modifier distrib verticale des feuilles tres identique
#distinguer duromb 1 et 2? (phase jeune = bourgeon et mature)
#ecrire reponses photomorphognese?


#V32 : photomorphogenese (et plus de sorties)
#ajout de fonctions pour calcul de ratio RFR dans RIRI6 (rfr_calc_relatif) et d'une fonction trilineaire pour la reponse au bleu (calculee comme une reponse au PAR).
#nouvelles sorties : phmgPet, phmgEntr, phmgPet_m, phmgEntr_m (permettent de verifier a quel moment lesfonctions de reponse a la photomorpho sont appliquees).
#nouvelle facon de convertir "Lsorgans" en fichier de sortie: a chaque iteration, la liste "savelsorgans" stocke le lsorgan. La fonction de IOtable 'ecriture_csv_fromlist' permet d'en faire un csv.
#ajout de "TT" dans lsorgans.
#ajout dans les regles de production de l'apex de liniE, longueur initiale de l'entrenoeud. Chez la luzerne son absence ne se remarquait pas car il demarre longtemps apres les folioles mais dans le cas du TB ou il demarre avant les folioles, liniE est important.
#modification de leg_leaf_lucas : le calcul d'ecartement des paires de folioles pour les feuilles multifoliolees n'etait pas valable pour les grands nombres de folioles (~19). 
#modifie la condition pour l'arret de la production de tiges : nshoots-1 (et non pas nshoots, car la premiere tige a comme id "0", donc n'est pas comptee. Sans cette modif, un nshoots de "1" produit deux tiges primaires.)

#V32b : debourrement corrige
#un module D2 produisait toujours un apex A2 dont l'age etait 0...Pour qu'un nouvel apex A2 produise bien sa premiere feuille apres PyllochronII degres-jours, il faut qu'a sa produciton il ait un age initial correspondant au temps passe entre le debourrement et le STEPS! Corrige dans cette version.
#entrenoeuds: calcul de longueur dans le In(): unite incorrecte. La division par 100 necessaire pour avoir des m est deja faite dans le calc_lent. --> corrige
#modifie la condition pour que les feuilles passent en mature: precedemment c'etait a l'iteration apres qu'elles ait atteint 95pourcent de leur taille finale. Maintenant, comme pour les entrenoeuds et les petioles, c'est quand le potentiel de croissance "pot" est infinitesimal (0.005). Une condition "age>ParamP[nump]['delaiF']" permet d'eviter que la regle ne s'applique au tout debut, quand le potentiel "pot" est aussi infinitesimal un petit moment avant la point d'inflexion!
#invar['countsh'] etait augmente deux fois a la production d'une nouvelle tige! corrige

#V32c - lucas
#interpretation graphique au "Start()", pour garantir une bonne execution depuis l'exterieur
#leg_leaf_lucas corrige: mauvais calcul du nombre de rangs (decalage de 1 pour les nombres des folioles paires : 4 folioles comptait 1 rang, 2 folioles comptait 0 rangs, alors que seul 1 foliole devrait compter comme zero rangs.
#invar['countsh'] compte deux fois = retabli, car cela donne un ID unique a une tige cree a la coupe par "redemarrage" de son bourgeon D (creation d'un B)... Le but de "CountSh" n'est pas de faire une sortie!!! Il est utilise comme entree, et ne sert pas a compter les tiges actives (countshexp est fait pour ca).
#profil de nombre de folioles: minimum = 1 foliole, 0 folioles ne doit jamais etre possible!

#V32d - lucas
#changement du calcul de rang de secondaires de "rank+rankp-1" vers "rank+rankp", car la formule precendente donnait des organes de rang "-1"!! (ce qui correspond donc au dernier rang, parfois tres grand si le profil est croissant sur la fin...). Les rangs sont comptes a partir de 0 et pas de 1! Ca ne se voyait pas auparavant, car il y avait des profils parcimonieux utilisant 'ordonnee 1, pente 0' comme deuxieme morceau de la bilineaire (l'idee etait d'eviter d'avoir par extrapolation des augmentations absurdes si on depasse le rang maximum du jeu de donnes de calibration)

#V32e - Lucas
#
#allocation aux racines selon fonction rootalloc (these Vincent Migault 2015). 
#ajout d'un parametre DurGraine: dans les regles de production de RA(), aucune limitation trophique n'est appliquee jusqu'a un certain stade (vidage de graine) (~environ stade 1 ou 2 feuilles par defaut)

#V33 - GL
# amelioration du tallage -> introduit un parametre de stade de debut de tallage 'debTallage' (Stage at with tillering (/primarry branching) occurs in the taproot zone - number of primary leaves)  et de vitesse de tallage 'RvitTallage' (ratio phyllochone tallage : phyllochrone seminal stem)
#-> production de nouvelles tiges n'est plius plus tous les phyllochrones des la levee
#desactive effet NBexp et D qui se transforme en B pour augmenter le nb d'axes generateurs (control plus fin de la vitesse de tallage a present, y compris plus lent!)

#modifie RootMorpho: calcul automatique de ELD (car parametrage mathieu pas bon et surestime diametre des petites racines)
# ajout de deux fonctions pour calculer duree d'elongation et life span des racines - pas encore activees car 1er test semble indiquer qu'on sous-estime le SRL-> eval lucas

# en cours:
# introduit 'delaiMaturBud' (Delay of bud maturation to reach an equivalent stage of 1 leaf) -> pour moduler le stade des B() apres une coupe (eventuellement aussi pour signifier que produit pas de B apres une coupe -> annuelle comme pois! -> valeur -1)
# ajout de invar_sc['sh']['MaxNI'] pour stocker nb max des NI de chaque tige et piloter stade des B() fille
#ajout de fonction MaturBud(delaiMaturBud, NIparent) qui genere ecart de stade des B() (en phyllocrones) selon stade de developpement tige parente et delaiMaturBud 
#introduit devalage 'deltaBud'  a production du A()
#test: effet moderer sur vitesse de croissance du LAI, mais peu sur delai initial

#+ gagne un step en chaintant le passage oblige par D de statut 1 (passe de D0 -> B())
#pourrait potentiemment passer directement a A() sans B()
#ou pourrait tricher et lire les coupe à l'avance pour que soit un B() déja au moment de la coupe? (non car a besoin de savoir quelle tige a ete coupee!)
#demande a Fred si y a moyen d'appliquer plusieurs regles en 1 step?

# si coupe et pas atteint -> stade ente -2 et 0 (sauf si valeur negative)
# si atteint ou depasser (initie avec rang qui depasse (max 4)
# ouraisonner en stade atteint par tige porteuse??

#ok mais arret des ramif de lucas marche pas comme attendu -> manque sur tige seminal mais a tous les rangs sur les primaires... -> revoir avec lui


#v34 test solN -> remplacer sol par solN en 1D et verifier solrties FTSW sont similaires

#Etape a: recuperer toute les entree et faire touner sol N en parallelle -> OK (pour le moment demande en N plante forcee a 0)
# #fermeture des bilans (S2.CloseWbalance())-> print cause pb: les sortir en fichier!
#compare en sortie les FSTW -> legerement different (moins de stress au debut pour solN) -> lie a legere modif bilan hydrique v4
# Etape b: debrancher sol et faire agir solN -> tout marche!!!
# Etape c: enlever les entree de sol initial -> OK, aucun souci

#v35 : tester en configuration rhizotron pour croissance racinaire+plevement d'eau en 1D
#ok -> sortie par horizon de sol avec out_HR
# mais LAI un fort/ profondeur d'enracinement un peu sous-evaluee / profil de racine pas tres bon (trop surface
# pour prelevement d'eau: pas si mal pour un premier essai / sachant que pas correction pour pivot et points precedents a corriger
#Profil des racines en surface au lieu de profondeur :-Sensibilite stressH des racines? / -Geometrie des racines? 

#mais plante a 2e repousse - pb de gestion des nom d'apex dans SurfVerte de tige!!!! -> debug



#v36 feedbackN
# change reponses stress hydrique en sigmoide + introduit reponse azote sigmoide -> ls_stressNNI : OK
#A faire = ajout de reponse RUE a stress hydrique et N ->OK
#Ajout reponse croissance dev a azote->OK
#test avec competition fixateur / non fixateur ->??? change rien???
#Normal -> Nmineral du sol enorme et tres peu de fixation - mais non fixateur ne fixe pas!
#test avec initialisation nitrate a zero -> NNI vers 0.6 -> differences restent faibles  + fixateur pas a NNI de 1??+ epsi<<1 (plantes isolees)
#essai en dense pour voir?
#visu des plante avec couleur NNI?

#A faire:
#activer la demande N plante + bilan d'N plante et sol
# ajout dans invar de 'DemandN_Tot' et affichage
# initialement ls_Act_Nuptake_plt renvoie que des Nan?? et du coup ratio aussi
# m _NO3 aussi donne Nan des le debut?? -> trouve : c'est ls_demandeN qui doit pas etre a  zero -> ?? -> debug

# active somme de demande feuille/pet/tige  
#A faire: a comparer avec une demande par defaut basee sur courbe critique
# fonction par defaut 'demandeNdefaut()' dans module_solN a utiliser
# initialise invar 'Mtot' avec le PMG -> OK, mais a genere des bug

# initialiser aussi le PMG -> passe par initialisation de MSaerien et d'un  'Naerien' (g d'N plant-1)  a partir de teneur en N ini
# a faire: pousivre ls_demandeN_bis

# -> recalcule Npc, QN plante puis demande a stocker dans invar['DemandN_TotBis'] -> DemandN_TotAer
#2 methodes ont une legere difference de demandeN  -> probablement pas les meme Npc pris en compte + meme ordre de grandeur
#faire un Npcbis ou le calcul est refait
# ls_demandeN_bis a forme de array byzarre (pas 1D) ->OK (lie a initialisation de Naerien)
#version bug qd re-run?!  -> revenir a version 35a?-> non bug aussi? -> 34c est OK -> c'est le 'sys.stdout.close()' qui faisait plante les print!

#pb :ls_Act_Nuptake_plt bien inferieur a demande en debut de cycle!!!?? (facteur 10000 ou plus? -> pas meme ordre de grandeur!) -> pb unite??
#ls_demande attendu en kg N.surface de sol -> en kg d'N dans le module de sol -> gagne un facteur 1000, mais reste un facteur 10 a 100 entre demande et uptake??
#unite dans les longueur de racines?? (m en cm?) -> RLTot fourni en m, mais matrice de densite apparente fournies en cm dans le test fixe-> probable! modele sol attend en realite ?
# Diffusive_Nflux() -> attend m et convertion ok en cm
# FLUXRACs() -> a aussi un facteur 100 qui est utilise pour passer en cm
# ls_roots de l'ecemple fixe a un *100 (mais devrais etre/100??) -> verifier unite racine en detail (pour retrouver res coherents)
# exemple fournit des cm de racine / voxel -> qd multiplie ls_roots*100. (#cm) -> sortie de Nuptake deviennent coherentes 
#pb d'unite des parametres??? -> faudrait verifier en detail dans 'debugN_rhizo.py' (pour le moment a l'air de marcher qd pas limiter par absorption active.... d'ou le besoin d'accroitre de beaucoup des longueurs de raines? -> verif quel processus limitant)

#+ pour le moment compare des Demande N totale (sans Considere mise a jour de Npc-> cumulee) a N uptake intantane
# -> active effet uptake sur Naerien et demandeN

#mettre Naerien, Npc_bis, Nuptake_sol en sortie -> OK
#donner acces aux sorties sol! - apres les close -> faire ecriture fichier R -> faire fonction qui recupere les serie temporelle des bilanN... (apres ecriture du dico) -> dicout, mais ecriture du dico plante??

# calculer un NNI dans invar -> OK!
#mise en place fixation 
#remplace vTT par invar['TT'] par coherence - test_retard devra y etre affecter! -> OK
#calcul d'un Ndfa (fraction)-> depend stress stade (fonction Ndfa_max()) et stress hydrique ->OK
#pour fixation relle (fonction ActualFix()) : calculer une demande residuelle apres uptake sol -> semble OK

#mais visiblement problemes d'unite entre demande, Nuptake sol etc...
# A faire: verifier unite! / semble prelever un peu + que demande mais NNI pas a 1?? + pareil dans NDFA
# Test avec uptake sol=demandeN donne bien les Npc attendus; NNI dans ce cas legement superieurs a 1 (a pris + que necessaire??)
# pb semble venir de capacite de fixation trop limitee -> revoir calcul/unite -> exprimer directement en lien avec biomasse aerienne ->OK
# fixation semble OK 

#mieux gerer biomasse residuelle (fonction de nb d'organes residuels apres coupe?)
#reinitialiser Naerien avec meme %N, mais nouvelle biomasse?
#!gere Naerien apres la coupe! -> Apres coupe tout devient Nan
#reinitiale Maerien et Naerien avec espilon pour eviter le bug
#-> tourne, toutefois Npc devient n'importe quoi juste après coupe car uptake sol de espilon qui donne un ratio de 10e5 -> revoir les arrondis
#+laisser une biomasse résiduelles apres coupe (fonction du nombre/taille d'organe restes apres coupe (faire une proportion?) -> verification des arrondis!!!


#A faire: lire fichier parametre sol
# 
# activer feddback NNI / Ajouter cout de fixation sur RUE (RUEfix?)
# 
# tester en 2D/3D!!
#Rq: faire visu des INN pas plante par un gradient de couleur serait super dans une animation d'association



#v36b / 37
#rajoute la reponse non lineaire a la temperature : beta Graux (paramtetres Tmin, Tmax et q)
#separe meteo et management en 2 fichiers separes
#rajout des paths automatique dans les chemins entree / sortie
#ajout de 'azomes' dans les sorties du bilanN
#ajout des sorties de senescence des parties aerienne: dMSenFeuil et dMSenTige
# ! senescence calculee sur la base de SLAmin -> a la mort de la plante il y a un residu (somme des aer - senesc) qu'il faudra remettre pour boucler les cycles!!
# ! faudrait en plus ajouter carto de distribution des senescence (somme de tooute les plantes mais dans l'espace) pour coupler avec le sol

#v37b
#passe tous les parametres sols dans par_SN
#lecture externe des parametres sols dans un fichier
# corrige  bug des rank de profil -> >max = derniere valeur du profil
#sortie des valeur de biomasse de pivot et rac fines dans outvar
#calcul d'un ratio de satisfaction de demande C des tiges R_demandC_shoot
# limite allocation aux racine qd demande des shoot pas satisfaite (priorite tige jusqu'a autotrophie stucturale)


#erreur de lecture pour caldul de dM -> !au unite -> convention I0 en PAR! -> ok

##37c
#correction d'un bug d'allocation aux racines (avant etait alloue en fonction de fraction root/tige au lieu de proportion)! -> ajout ds la fonction rootalloc pour passer en proportion!
#ajout d'un facteur 0.95 dans calcul de dMS pour tenir compte de reflexion du couvert
#ajout de sorties du bilan C plante dans le dicout du bilanN
#ajout d'un stressFIX sur la RUE pour tenir compte du cout de fixation sur bilan C (param NODcost)
#place calcul des demandC dans le starteach() (avant remis a zero du tableau de la veille)
#ajout remob pivot: calcule ce qui manque pour etre a structural mini en aerien et une remobilisation des pivots por le couvrir(remob) -> effet tre faible (mais bilan OK ->)
# allocation entre feuille et tige revue: sur la base de demande en C respectives!
# devrait revoir parametreage : SLAmin/Lineic mini tige et petiol adapte pour bon rapport F/T + verif sur TB (pb de MAearien remis a zero a la coupe)


#37d
#calcul epsi revu pour etre exact -> OK
#remob pivot revue: sans arret (no priorite) des racines -> retire filtre_ratio(invar['R_DemandC_Shoot'])
#ajout des parametres ADIL, BDIL, NODcost lus dans le fichier param
#preparer fichiers de lusignan30? -> OK
#introduction du TTrac pour piloter developpement des racines!! -> requiert Tsol! -> OK

#37e
#ajouter phase dilution dilution plante isolee: parametre BDILi -> OK
#ajouter les compartiments pivot et fine root pour l'N -> OK
# gestion de la demande -> Noptpiv et NoptFR = supposee constante
#allocation proportionnelle a demmande relatives d'N des compartiments! (pas de priorite)

# pas de remobN -> pourrait l'implémenter en // de remob pour C

#37f
#ajout senescence reguliere des racines -> definir delai en jour apartir des LDs de chaque ordre
#calcul des LD des differenst ordres dans le start -> ok
# calc_root_senescence dans rootmorpho -> ok
#!! paremetrage de GDs, LDs, et RTD va etre hyper sensible! -> avoir dans le detail

#retirer aux dL -> faire les calcul brut/net ->  OK
#retirer a Longueur tot de racine -> RLTotNet 
#retirer a  masse de racine fine -> OK
# calcul du SRL avec valeur nette + branche pour absorption -> OK
# bilan N des racines -> calculer QN rac mortes -> 'perteN_rac_fine' OK


#37g
# debug croissance racine ini: DurGraine s'applique a enveloppe mais pas a croissance des racines
# + pas de photosynthese avant premiere feuille car pas de cotyledon
# -> met MSaerienne graine dans cotyledon (Mcoty), et le converti en surface ini (pendant DurGraine)
#essaie avec sd() -> marche pas car surface relacule a chaque date
# rajoutee a grille 3D dans m_lai avec calc_surfcoty -> OK
# rajouter aussi les PARa des cotyledon : calc_parapcoty -> OK


#ajout la limitation de la duree d'expansion des enveloppes qui depend des diametres!-> OK
#A faire: pour trefle/multi-roots
# -> ajout d'une ponderation axe du PARa (fraction allouee aux autres pivot du meme axe (distance) et au pivot seminal central) -> OK (pas de param)
# -> ajout d'une ponderation allocation en fonction de FTSWaxe -> racines ds le sec ne se developpent pas! et realloue a mieux positionner sur axe ou pivot seminal
#-> ou recuperer FTSW axe? -> pour le moment nulle part! calcul base sur somme a l'echelle plante avec build_ls_roots_mult
# il faudrait a partir du ls_systrac et du sol recaluler FTSW par axe a chaque step pour ponderer -> A FAIRE dans rtd (1) et sol (2)
#1) spatialise sous systeme, 2) ls mask root_eff/ maskASW et maskTSW et FTSW correspondante (prend une liste de grille 3D)
#risuqe q'augmenter pas mal temps de calcul et pb memoire (gerer autant de grille sol que de Iaires!) (eventuellement restreindre en 1D?)


#satisfaction des besoins racines non nulle mais toujours tres < a 1 tant que pas de feuilles emises!
#C graine des racines pas remobilise...
#mais suffirai pas: cotyledon fournissent 10-4 chaque jour / rac+pivot c'est 4.10-4 au total (20% grraine) -> au mieux qqs jours (pas 60)


#debut demandeNdefaut2 pour plafonner Ncrit (peur pas depasser 100%!!) -> limite a 9%- >OK
#implemente NremobC -> pour remobiliser N en // de remob pour C (sinon forte baisse de %N et NNI???) -> OK
#rq: -> pourquoi absorption N suit pas?
#bug au premier tour??


#37h: ajoute seed et test sol spatialise 3D

#debug d'un age+STEPSsol dans RA() -> OK
#+ debug step initiaux: initialise le B avec 1 age = phyllochrone (pour gagner ce step)->OK
#+ debug un else L2516 dans le B()->OK
#Pour sol spatialise: en 2 etapes:
#  1) connection en passant input en 3D: ajout des parametres discret_solXY et mis a jour du lims_sol et de l'initialisation du S. avec bon dxyz -> OK
#  2) remplacement des reponses des racines laterales S.ftsw_t[Horiz][0][0] par mean(S.ftsw_t[Horiz,:,:]) -> OK (prend moyenne dans l'horizon; L3028; L3063; L3073; L3180)


#37hbis: ajout visu map en sol 2D + lecture d'un fichier d'initialisation des variables du sol
#decalre sol en module (ajout d'un argument pour le nb de colones) + cree module solxy qui est interprete graphiquement pour chaque colonne
#pb: sol complet visualise en n steps (pas 1 seul...)
#sinon a l'air ok
#dico inis recupere les vecteur d'initialisation du profil de sol
# debug shoottype des ramification de la tige seminale sur distance au collet (L2648) (avant lucas base sur nsh)
# ajout d'une variable 'NBphyto' dans invar et outvar
# ajout en 1ere ligne de outvar d'une ligne 'colnames' qui contient les noms d'onglet de chaque plante
# !!! photomorph etait force a 1.!! reactive photomorphogenese!!
# Ajout de lecture de Hcut en dynamique dans le fichier mng
# ajout d'une sortie cutNB spécifiant le numéro de coupe depuis levee (pousse ini=0)
# modification du module Lf et de la recontruction des feuille pour tenir compte des feuilles multi-folioles (sainfoin canto)
# debug L2573 pour regulation des delai de tallage avec B(exp)
# passe le sd de delaiMaturBud a 4 delta par default (comme Lucas)


#37hter: modif de prise en compte des STEPS et de periode de germination
#changement de l'initialisation du temps thermique des plantes: au passage de B() -> A() de la tige seminale
#ajout de invar d'un variable 'germination' (0/1) qui lance calcul temps thermique
#pilotage des croissance et expansion averienne par invar['dTT'] et plus par STEPS; passe STEPS en variable locale
#modif des conction requerent dTT dans le module root_morpho.py -> root_morpho2.py + fonction calcDemandeC
#pilotage des croissance et expansion racinaire par invar['dTTsol']; passe STEPSsol en variable locale

# ajout d'une fonction germinate() et de reserve_graine() pour faire germination au step de la germination (TT=0) et pour gerer apport reserve graine sur la duree de DurGraine
# pour especes a petite graines reserve_graine() a un effet mineur! -> peut pas soutenir croissance racinaire (c'est les cotyledon qui le font)
#revoit SLA coty pour avoir surfaces cotyledons realistes
#gerer allocation racine tant que 1ere feuille n'est pas la?? -> condition pour que froot uniquement aux racines; puis suis relation allometrique
#delai entre germination et feuille 1 actuellement de 2 phyllochrones: pourrait offrir la possibilite de changer ca ?
# Ajout d'un lsApxeAll qui comporte Apex Actifs et arrete: NBI compte sur cette base pour eviter bug de comptage qd il y avait des arret

#passe frac_coty_ini dans le ParamP pour gérer différence pois (pas de cotyledon a germination)
#debug depart de B() dans condition lumière: newpar a la place de par

#changement d'IOxls pour eviter bug sur DA a la lecture des parametres sol
#changement de inis pour lire tous les parametres d'initialisation sol dedans
#pourrait faire pareil pour param scene au niveau aerien?

#ajout d'un GetUp avant chaque module feuille: pour recuperer azi reel des feuilles muttifoliee independamment de leur axe
#ameriore grandement simul avec grosses feuilles - 
# applique aussi multifoliole aux feuilles trifolie grosse (>10cm2) pour mieux distribuer la surface foliaire

#modifie sortie cutNB sinon plante a lecture dans R
#ajout sortie nombre d'apex actif pour corriger les nbr toto de phytomere par rapport aux observe
#dans ls organs ajoute, DOY, cutNB et larg pour aider les validation
# modifie le nb de foliole Normnfol des multifoliolee (au max Nfol, avant augmentait indefiniement)

#modifie effet photomorpho PAR: introduit modulation par la photoperiode (reponse en fait etablie en instantanee)


#37hquad: separation de N piv en structural et reserve (invar['NreservPiv']); 
#flux des reserves N piv vers aerien si absorption et fixation suffisent pas a satifaire demande N aerienne
# calcul de invar['NreservPiv'] avec nouveau parametre NminPiv -> OK
# calcul de demande aerienne non satisfaite par root uptake et fixation -> OK
# ajout de NremobN qui est l'N du pivot remobilise ->0K
#suggere MaxFix pas assez haut -> recalcule a 36
# Ajout d'une courbe de réponse distinguant réponse de ramification à l'N de réponse du développement des axes primaires (comme pour l'hydrique) -> nouveaux parametres 'NTreshDevII'

#modifie condition menant a germination: ajoute possibilite de germe meme dans le cas ou on est deja a nshmax (e.g. cas du pois qui sinon ne gernmait jamais)
#pour pb d'oscillation des elv0: passer Lmaxeffet a 10000 pour rendre negigeable facteur de correction -> pilote directement avec les tirages d'elv0


# A FAIRE!!!
# -> rendre allongement des entre-noeud sensible a PAR max du phytomere (pas juste In, mais aussi Pet) -> recherche ds la chaine (en attendantreponse au PAR differente pour ces organes)
# -> rendre tallage effectivement indexe en temps phyllochronique (actuellement part meme si primaire arrete) -> bloque!



#37h_quad_initc
# changement du sol utilise (solN3.py) -> debug + ossibilite de prendre en compte obstrac
# defiition d'un obtarac par defaut a None dans les entree sol (carto 2D de profondeur en m)-> projet sanxay
#!! bug avec obstarac_ = None quand definit en global ??? -> lie a l-py? -> OK coutrournepar les type()


#test d'initialisation avec des residus -> OK! fournir bon vprops1 (bon nb d'horzon)
#ajout des calcul de mineralisation: OK
#test de simul avec ajout d'un residu predefinit dans le premier horizon de sol (feuilles)
# consrtuire marice des residus: mat_res alimentee ar les feuilles : OK
# stipules et petiole ajoutes dans matrice des feuilles: grosse part liee aux petioles... revoir parametrage?
# mat residu tige et rac_fine alimentee par senescnce

# dans module de sol: offrir la possiblite d'jouter de la matiere a une forme de residu existante -> OK = fonction S.mixResMat()
#couplage avec option residu en dynamique: OK, fonctionnel
#ajout des sorties des rsidus dans le fichier de sortie du bilan C/N ->OK
# passe lecture des groupe_resid depuis fichier plante -> OK
# mais force a 2 groupe_resid pour initialisation car sinon bug qd des residus de l'esp 2 seulement: revoir comment gerer ca...
#ajout d'options de visualisation du sol, des racine et des tiges (regles d'interpretation optionnelles)


#A faire 
# pour pivot respe a zero! -> ajute variable de mort des plante et disparition des racines et pivots qd ca arrive -> A faire
#ajouter un deuxieme groupe de residu au moins (2e espece?)


#A FAIRE : + changer distrib_dM_ax pour bien simuler couverts a racines multiples / rhizomes



#faire varier duree de vie des racines en TT, pas en Nb de jours! -> fenetre glissante de plusieurs jours (ou fraction de jour si pas complet)
#A faire aussi distribution spatiale des residus et feedback N via le sol!!


#manque encore senescence des plantes mortes!



#A faire :
# faire sorties du bilan N plante et verifier equilibre
#-> gestion de mortalite des racines et effet sur les bilans de C et N
#alimentation des pools de residus pour le sol



#basucler les calcul du bilan de DM et N dans un fichier externe?

#!! A faire: pb de cumul de degre jours! tous les ages avancent selon STEPS -> faut utiliser invar['NNI'] = personalise par plante!

#comparer a ce qui etait trouve pour densite de racines forcees et verifier les uptake totaux qd avec plusieurs plantes?
#tester avec les RLtot simulee













#A faire rainces:

# au debut -> pas de croissance de racine car plante trop petite -> mettre une graine? (ou reserve initiale >0) ou durre initiale sans strssC??
# ajouter effet forme cylindre sur densite racine (pas juste BBox)-> fonction sin au caree
# introduire senescence de racine et distribution dans la grille de sol

# elongation secondaire racinaire fonction de strate de sol ou est l'apex (coin bas du cylindre) / de moyenne des horizons?
#voir si pivot trefle OK (garder une frcation de tous les axes pour le pivot?)

# prevoir une sortie des densite de racine (car pas homogene)  /carte 2D? profil 1D? par plante?

#A faire:
#trefle morphogenese depend rayonnement des petiole/feuille

#puis comparer cette version et une version 3D racine lucas... (e.g. donnees de rhizotron grande capacite)





#-> parametre de geometrie elv0 a 0 pour eviter tige qui partent vers le haut


#pb sur trefle que qqs secondaires qui persisiatnt 
# sans ramif (Active branch=0), pb persiste -> en fait OK -> c'etait nb de tige qui etait a zero...

# arrive meme en desactivant 'elvtresh' ->?? passe jamais ds cette boucle -> lie a pb de geometrie! -> angle semble etre de 45degres...


#+ 

#-> primaire meurent apres coupe? -> condition de mort devrait considerer plus de surface verte et apex a l'arret ou ombre depuis longtemps?? -> artefact? a tester


#Rq: reguler mort des tiges sur base de surface verte -> gagne un peu en LAI, fait mourir + de tiges et plus de A2/D2
#faire mourir/reguler aussi les D2 en fonction de deux axe?

#ajouter rhizomes a demande en C


#-> tester differentes densites... pas l'air aberant



#Rq: dans la regle de production du B: premiere tige pas aleatoire a cause du SetHead()/(azi)&(90) (a passer dans l'interpretation du SHP???)
#Rq: sur trefle giga: pb de geometrie de la premier tige??? qui est erige (pas prise en compte de correction tige seminale??)

#ajout d'une fonction pour calcul des surface foliaire par tige : calcSurfScale
#-> pour detecter tiges a l'arret dans surface -> mort!
#si apex a l'arret depuis x temps + plus de surface sur tige -> apex detruit + ajout de nsh a tige morte
#faire disparaitre bourgeons basal et noeuds de ces tiges mortes!

#pourrait changer ordre des champs ds lsApex?? -> adapter cumul_lenIN/autres fonctions?

#rq: de visu constate derive de la Deance en C mini-> tend a passer au dessus de l'offre avec le temps
#rq: demande mini en C des feuilles et petioles OK / entre noeud par contre semble tres eleve???
#pourrait reguler de facon encore plus severe (non plus sur surface, mais sur para avec 1 seuil !!
#sur le meme principe, faire un dico par tige du rayonnement des premieres feuilles -> arret apex depend de max( apex, feuille)-> pour que ca fonctionne aussi sur TB/rampant!

#pb: a une meme position topo: plusieurs apex secondaires?? non-> juste que rankp pas sorti initialment pour connaitre top-> le rajouter


# a faire: introduire tt_omb dans apex -> tige 1 meurt quand derniere de ces feuilles meurt -> en compet verticale = c'est comme les feuilles / plus complique pour trefle rampant?? -> travailler par axe?? (sauf pour tes jeune tiges= bourgeons? <3 noeuds? -> rhizomes)
# ou gerer au travers de surface foliaire restante sur l'axe plutot que tt_onb-> ou est cette info?
# + faire mourir le bourgeon non dormant fille -> stocker info des id de tiges morte par ombrage qqs part?(faire disparaitre noeud et 
# attention de ne pas retirer celle des tiges coupees??
#utiliser lsOrgans ou crere une liste d'axes inactifs?



# a faire:fichier parametres sol externes



#A faire: 
#prevoir sortie/calcul #demande/teneur en azote! sur la base de la distrib d'eclairement
# 1) calul des I/I0 par strate et plante -> distrib d'N et Qfeuille a INN=1
# 2) faire qqchose pour tiges
# 3) pourra faire connexion avec Farqhar et tester calcul d'An

#introduire intrapolation dans un voxel pour determiner le par des apex (limite pb lie au nb de couche en z sur morpho -> OK c'est fait
#ameliorer par des B (pris sur la base de carto et pas de la position reelle des bourgeosn-> pb pour stolons)
#introduire morpho du trefle (effet croissance en/pet + 2sites perception apex -> tiges/ feuille -> petiole/limbe (thompson 1995)


#incoherence ? -> calcul interceptionde rayonnement dans le strateach, puis croissance biomasse/reste dans les end_each??
# interpretation se dait sur structure apres les regles de production donc sur l+dl -> pas pris en compte ds surface et longueur ?e stade!


# reponse photomorpho/rayonnement -> a passer en relatif I/I0? -> avec par_tresh deja le cas!
# preciser le par au niveau des apex en interpolant en fonction de Z0 a l'interieur d'un voxel (pluutot que prendre niveau de tra
# sensibilite au rayonnement des apex? -> faire sur la base de la derniere feuille mature ou plus grande feuille en 'exp' de l'axe
#l'interpretation geometrique est-elle necessaire dans le modele? -> quel gain de temps si on la switch?
#sans feuile gagne environ 25-30%!!
# 45s -> 33
# 121 ->  81 (animate) / 73 (run)

# !!!! SHP: pb n->n+1 tirns pas compte de TT/longueur -> a modifier

#rq: une baisse dans les vitesses de calcul passe de 33/34 a 39s?? au moment ou rajoute les parametres dasn feuilles/In... ; pas lie aux calculs offre/demande



# Rq: les prints rallentissent considerablement l'execution
# la visualisation aussi animate vs run
# bilan hydrique legerement

module Sd(nump) # Seed
module A(nump, nsh, statut, age, duromb, rank, phyllotax) #primary shoot Apex
module A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax) #secondary shoot Apex (rankp= rang sur porteur)
module D(nump, nsh, statut, age, posi, parent) #Dormant bud of the crown
module D2(nump, nsh, age, rankp, phyllotax,shoottype) #dormant bud at the leaf axil
module B(nump, nsh, age, posi, nrhiz, azi, par, statut) #active Bud of the crown nsh=numero de tige; rhiz  nb noeud de rhizome
module SHP(nump, azi, elv0, posi, nbp,par) #SHoot Parameters: nbp et par pour moduler incli_ini en fonction de longueur et lumiere
module In(nump, nsh, age, rank, rankp, l, statut, ordre) #Internode (l longueur normalisee)
module Lf(nump, nsh, age, rank, rankp, l, tt_omb,statut, ordre) #Leaf (l longueur normalisee)
module Pet(nump, nsh, age, azi, l, statut) #Petiole
module Stp(nump, azi, l, statut)#Stipule
module RA(nump, nsh, age, rankp, agecum, moduloH) #primary Root Apex
module RB(nump, nsh, age, rankp, statut) #adventive root bud
module RS(nump, nsh, rankp, moduloH) #Root Segment
module RLB(nump, nsh, age, rankp, Horiz) #Root Lateral Bud
module RLAP(nump, nsh,age,rankp,l, Horiz) #Root Lateral Apex Prospection (max diameter reached by secondary roots)
module Coll(posi) #Collar 

module sol(S, nbcol) #objet sol entier (nbcol en y)
module solxy(S, idcol) #colone de sol pour visu 2D
module attente(n) #pour attendre initialisation des variables avant de representer le sol

Axiom: [attente(1)][Sd(0)][Sd(1)][Sd(2)][Sd(3)][Sd(4)][Sd(5)][Sd(6)][Sd(7)][Sd(8)][Sd(9)][Sd(10)][Sd(11)][Sd(12)][Sd(13)][Sd(14)][Sd(15)][Sd(16)][Sd(17)][Sd(18)][Sd(19)][Sd(20)][Sd(21)][Sd(22)][Sd(23)][Sd(24)][Sd(25)][Sd(26)][Sd(27)][Sd(28)][Sd(29)][Sd(30)][Sd(31)][Sd(32)][Sd(33)][Sd(34)][Sd(35)][Sd(36)][Sd(37)][Sd(38)][Sd(39)][Sd(40)][Sd(41)][Sd(42)][Sd(43)][Sd(44)][Sd(45)][Sd(46)][Sd(47)][Sd(48)][Sd(49)][Sd(50)][Sd(51)][Sd(52)][Sd(53)][Sd(54)][Sd(55)][Sd(56)][Sd(57)][Sd(58)][Sd(59)][Sd(60)][Sd(61)][Sd(62)][Sd(63)]#[Sd(64)][Sd(65)][Sd(66)][Sd(67)][Sd(68)][Sd(69)][Sd(70)][Sd(71)][Sd(72)][Sd(73)][Sd(74)][Sd(75)][Sd(76)][Sd(77)][Sd(78)][Sd(79)][Sd(80)][Sd(81)][Sd(82)][Sd(83)][Sd(84)][Sd(85)][Sd(86)][Sd(87)][Sd(88)][Sd(89)][Sd(90)][Sd(91)][Sd(92)][Sd(93)][Sd(94)][Sd(95)][Sd(96)][Sd(97)][Sd(98)][Sd(99)]#[Sd(100)][Sd(101)][Sd(102)][Sd(103)][Sd(104)][Sd(105)][Sd(106)][Sd(107)][Sd(108)][Sd(109)][Sd(110)][Sd(111)][Sd(112)][Sd(113)][Sd(114)][Sd(115)][Sd(116)][Sd(117)][Sd(118)][Sd(119)][Sd(120)][Sd(121)][Sd(122)][Sd(123)][Sd(124)][Sd(125)][Sd(126)][Sd(127)][Sd(128)][Sd(129)][Sd(130)][Sd(131)][Sd(132)][Sd(133)][Sd(134)][Sd(135)][Sd(136)][Sd(137)]

#Axiom: [pattern(0)sol(S)]plantation(nbplantes-1)


derivation length: DOYend-DOYdeb#200#98#224#73#93#66#93#66#149#119#179#300#365#(jours)
production:

#plantation(nbplt):
#    if nbplt>=0:
#    #for i in range(0, nbplt):
#        nproduce [Sd(nbplt)]plantation(nbplt-1)
#    else:
#        produce *


Sd(nump) :
    produce: Coll(carto[nump])RA(nump,0,-1,0,0,0)][SetHead()/(random.uniform(0.,360.))&(90)B(nump,0,ParamP[nump]['phyllochron'],carto[nump],0,random.uniform(0.,360.),0,'exp')] #ouverture de [ racine dans le Coll

B(nump, nsh, age, posi, nrhiz, azi, par, statut):
    global ls_ftswStress
    STEPS = invar['dTT'][nump]
    
    invar['NBB'][nump]+=1
    invar['lsA'][nump].append(nsh)
    if statut=='exp':
        invar['NBBexp'][nump]+=1
    
    vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
    newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX # A ameliorer :pris sur carto et position reelle des bourgeosn-> pb pour stolons?
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1
    
    #control de la vitesse de tallage
    if nsh==0:#tige seminale -> pas d'attente
        deldeb = 0
    else:
        if nsh==1:#pousse initiale -> debut tallage
            deldeb= ParamP[nump]['debTallage'] * ParamP[nump]['phyllochron']
        #else:
        #    deldeb =  ParamP[nump]['phyllochron'] / ParamP[nump]['RvitTallage']
        elif statut=='exp':#bourgeon actifs produits sans dormance (tallage)
            deldeb =  ParamP[nump]['phyllochron'] * ParamP[nump]['RvitTallage']
        else: #bourgeons 'regular'
            deldeb = 0.
    
    #print 'B', nsh, age, deldeb
    
    if age >= deldeb/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDevII'][nump]) and newpar>=meteo_j['I0']*ParamP[nump]['par_tresh'] and nrhiz==0: #effet par_tresh marche mais a l'envers??? ->OK
        ##azi = random.uniform(0,360)
        elv0 = random.uniform(ParamP[nump]['elv0'][0],ParamP[nump]['elv0'][1])#(0,90)
        newageB = age%ParamP[nump]['phyllochron'] - test_retard[nump] 
        newageA = age%ParamP[nump]['phyllochron']+STEPS - test_retard[nump] 
        deltaBud = int(age/ParamP[nump]['phyllochron'])
        rpiv = invar['DiampivMax'][nump]/2.+ 0.5
        posini = array(carto[nump]) + array([random.uniform(-rpiv,rpiv),random.uniform(-rpiv,rpiv),0.])
        new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#5#0
        
        
        if statut=='exp' and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#nsh< ParamP[nump]['nshoots'] and  : #modifie en nshoots-1, sinon la premiere tige n'est pas comptee!
            #print nump, 'B', newageA, test_retard[nump]
            newazi = random.uniform(0.,360.)
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh+1
            invar['countShExp'][nump] += 1            
            invar['countSh'][nump] += 1
            newnsh2 = invar['countSh'][nump] #nsh+1
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                germinate(invar, ParamP[nump], nump)
            
            produce [@M(posi[0],posi[1],posi[2])SetHead()/(azi)&(90)B(nump,newnsh,newageB,posini,new_nrhiz,newazi,0,'exp')][D(nump,newnsh2,0,newageB,posini,nsh)]SHP(nump,azi,elv0,posi,0,newpar)GetPos(0,0,0)A(nump,nsh,1,newageA,0,0,azi)
        else:
            invar['countSh'][nump] += 1
            newnsh = invar['countSh'][nump] #nsh
            
            if nsh==0 and invar['germination'][nump] == 0: #tige seminale, production du premier apex
                invar['germination'][nump] = 1
                germinate(invar, ParamP[nump], nump)
            
            produce [D(nump,newnsh,0,newageB,posini,nsh)]SHP(nump,azi,elv0,posi,0,newpar)GetPos(0,0,0)A(nump,nsh,1,newageA,0,deltaBud,azi)
    elif age >= ParamP[nump]['phyllochron']/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDevII'][nump]) and nrhiz>=1:
        newageB = age%ParamP[nump]['phyllochron']
        produce F(ParamP[nump]['LenRhiz'])B(nump,nsh,newageB, posi,  nrhiz-1, azi, newpar, statut)
    else:
        newageB = age+STEPS
        produce B(nump,nsh,newageB, posi, nrhiz, azi, newpar, statut)



GetPos(X0,Y0,Z0)A(nump,nsh,statut, age, duromb, rank, phyllotax):
    global ls_ftswStress, lsAxes, lsApex, lsApexStop, lsApexAll#, Hplante, Dplante
    STEPS = invar['dTT'][nump]
    
    idsh = str(nump)+'_'+str(nsh)
    idax = str(nump)+'_'+str(nsh)+'_'+str(0)
    
    invar['lsA'][nump].append(nsh)
    
    if Z0>invar['Hplante'][nump]:
        invar['Hplante'][nump] = Z0
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
        invar['Dplante'][nump]=0.
        invar['lsA'][nump].remove(nsh)
    
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    ##invar_sc['ax']['MaxPARaF']
    
    try:
        PARlf = invar_sc['ax']['MaxPARaF'][idax]
    except:
        PARlf = 0.
    
    #print PARapex, PARlf
    PARsense = max(PARapex, PARlf) #niveau percu = mas d'apex ou feuille
    
    #print nump, age #malgre retard, tous les A ont le meme age
    if age >= ParamP[nump]['phyllochron']/(0.00001+ls_ftswStress['WaterTreshDevI'][nump]*ls_NNIStress['NTreshDev'][nump]): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARsense>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            if nsh==0:
                invar['firstleaf'][nump]=min(TT,invar['firstleaf'][nump])
                if rank>=1: #tige seminale, production de la premiere feuille
                    invar['germination'][nump] = 2
            
            newage = age%ParamP[nump]['phyllochron']+STEPS
            liniF = expansion(newage, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
            liniP =  expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
            liniS = expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            liniE = expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... Pour eviter ce genre de problemes et/ou des decalages bizarres, s'assurer a l'avenir que les delaiE, delaiF et delaiP soient normalises pour que le TT au point d'inflexion de la fct logistique soit a la moitie d'un phyllochrone.
            
            lsAxes.append([nump,nsh,rank])
            lsApex.append([nump,nsh, rank, 1, I_I0,duromb,''])
            lsApexAll.append([nump,nsh, rank, 1, I_I0,duromb,''])
            invar['NBapexAct'][nump]+=1
            
            #Lucas:
            #shoottype = 'primary' if nsh==0 and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1 else 'branch' ###permet de desactiver le D2 si il fait "double emploi" avec un axe primaire... Sans compter la tige seminale!!! (d'ou le nshoots-2)
            ###limite a la tige seminale : if nsh==0
            # corrGL: baser sur distance au collet
            dist_collet = distance(p1=array(carto[nump]), p2=array([X0,Y0,Z0]))
            shoottype = 'primary' if nsh==0 and dist_collet< 3. else 'branch'
            
            #mise a jour du NI max            
            append_dic(invar_sc['sh']['MaxNI'], idsh, rank+1)
            
            
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,0,liniE,'exp',1)[GetPos(X0,Y0,Z0)RB(nump, nsh,0,rank,0)][D2(nump,nsh,newage,rank,phyllotax,shoottype)][Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0)GetUp(0,0,0)Lf(nump,nsh,newage,rank,0,liniF,0.,'exp',1)]GetPos(X0,Y0,Z0)A(nump,nsh,1,newage, 0, rank+1, phyllotax+ParamP[nump]['phyllotaxy'])
        else:#ombre
            if rank>3:#si tige n'est plus bourgeon
                try:
                    if invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface
                        test=1
                    else:
                        test=0
                except:
                    test=0
                
                if test==1:#invar_sc['sh']['SurfVerte'][idsh]==0.:#si ombre et tige sans surface #invar_sc['sh']['Surf']
                    invar['lsApexMort'][nump].append(nsh)
                    try:
                        invar['lsA'][nump].remove(nsh)
                    except:
                        print str(nsh), 'pas trouve dans lsA'
                    produce *
                else:#sinon pause/arret
                    lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                    produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax)
            else:#sinon pause/arret 
                lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                lsApexAll.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
                produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax) #arret de developpement
            #lsApexStop.append([nump,nsh,rank, 1, I_I0, duromb+STEPS,''])
            #produce GetPos(X0,Y0,Z0)A(nump,nsh,0,age, duromb+STEPS, rank, phyllotax) #arret de developpement
    else: #pas atteint age de produire un phytomere
        lsAxes.append([nump,nsh,rank]) 
        lsApex.append([nump,nsh,rank,1, I_I0,duromb,''])
        lsApexAll.append([nump,nsh,rank,1, I_I0,duromb,''])
        invar['NBapexAct'][nump]+=1
        produce GetPos(X0,Y0,Z0)A(nump,nsh,statut,age+STEPS, duromb, rank, phyllotax)


GetPos(X0,Y0,Z0)A2(nump, nsh, statut, age, duromb, rank, rankp, phyllotax):
    global ls_ftswStress, lsApex, lsApexStop, lsApexAll
    STEPS = invar['dTT'][nump]
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARup = meteo_j['I0'] if vox[2] == 1 else res_trans[vox[2]-1][vox[1]][vox[0]] / surf_refVOX
    PARdown = res_trans[vox[2]][vox[1]][vox[0]] / surf_refVOX
    PARapex = PARup - (PARup-PARdown)*(Z0%dxyz[2]) / dxyz[2] #interpolation lineaire a l'iterieur du voxel
    I_I0 = PARapex/meteo_j['I0']
    
    if nsh in invar['lsApexMort'][nump]: #Meurt si tige porteuse meurt
        #print 'vrai', nsh
        produce *
    elif age >= ParamP[nump]['phyllochronII']/(0.00001+ls_ftswStress['WaterTreshDevII'][nump]*ls_NNIStress['NTreshDevII'][nump]): # introduit arret developpement des apex en fonction gradient vertical PAR
        if PARapex>=meteo_j['I0']*ParamP[nump]['par_tresh']:
            newage = age%ParamP[nump]['phyllochronII']+STEPS
            liniF = expansion(newage, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
            liniS = expansion(newage, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            liniP = expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
            liniE = expansion(newage, ParamP[nump]['aE'], ParamP[nump]['delaiE'])#ajout lucas: necessaire chez le TB! sinon, les entrenoeuds demarrent au milieu de leur croissance... 
            lsApex.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0,duromb, rankp])
            invar['NBapexAct'][nump]+=1
            
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp,liniE,'exp',2)GetPos(X0,Y0,Z0)[Stp(nump, phyllotax, liniS, 'exp')Pet(nump,nsh,newage, phyllotax,liniP,'exp')GetPos(X0,Y0,Z0)GetUp(0,0,0)Lf(nump,nsh,newage,rank,rankp,liniF,0.,'exp',2)]GetPos(X0,Y0,Z0)A2(nump, nsh, 1,newage, 0, rank+1, rankp, phyllotax+ParamP[nump]['phyllotaxy'])
        else:
            if duromb<ParamP[nump]['MaxSurvOmbr']:
                lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,rankp])
                produce GetPos(X0,Y0,Z0)A2(nump, nsh, 0,age, duromb+STEPS, rank, rankp, phyllotax) #arret de developpement du a ombre
            else:
                produce *
    elif PARapex<meteo_j['I0']*ParamP[nump]['par_tresh']:#ombre et hors production de nouveau phytomere
        if duromb<ParamP[nump]['MaxSurvOmbr']:
            lsApexStop.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            lsApexAll.append([nump,nsh,rank,2, I_I0, duromb+STEPS,duromb,rankp])
            produce GetPos(X0,Y0,Z0)A2(nump,nsh,0,age, duromb+STEPS, rank, rankp, phyllotax)
        else:#apex detruit au dela de MaxSurvOmbr
            produce * 
    else:#age avance car pas encore atteint de phyllochron   
        lsApex.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        lsApexAll.append([nump,nsh,rank,2,I_I0,duromb,rankp])
        invar['NBapexAct'][nump]+=1
        
        produce GetPos(X0,Y0,Z0)A2(nump,nsh,statut,age+STEPS, 0, rank, rankp, phyllotax) 




SHP(nump,azi,elv0,posi,nbp,par):
     vox = riri.WhichVoxel(carto[nump], origin_grid, na, dxyz)
     newpar = res_trans[-1][vox[1]][vox[0]]/surf_refVOX
     produce SHP(nump,azi,elv0,posi, nbp+1, newpar)
#??erreur nbp (nb phytomere devrait dependre meme regle que phyllochrone! (bon seulement pour cet exemple)

GetPos(X0,Y0,Z0): #Rq: le GetPos doit etre dans les regle de production (pas interpretation pour que coupe soit effective)
    if Z0>Hcut and isTTcut == True:
        produce Cut()

GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,age,rank,rankp,l,tt_omb,statut,ordre) :
    global  SurfprofilPlant, ls_ftswStress, lsOrgans #SurfPlante, PARaPlante, PARiPlante, Hplante, Dplante,
    STEPS = invar['dTT'][nump]
    
    
    dX, dY = X0-carto[nump][0],Y0-carto[nump][1]
    dist2 =  dX*dX+dY*dY
    if dist2 > invar['Dplante'][nump]**2:
        invar['Dplante'][nump] = sqrt(dist2)
    
    
    surF = calc_surF(nump, rank, rankp, ordre, l) #m2
    
    #gestion feuilles multiples: construction du ls_pts
    rk = rank+rankp if ordre==2 else rank
    rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
    nf = ParamP[nump]['profilLeafI_nfol'][rk]
    ls_pts = []
    if nf > 3 or surF >= 0.001:#10cm2
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
        Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        ls_pts.append( leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False))
        p1, lvec, rrec, r_azi, inclivec = conv_cyl(array([0.,0.,0.]), array([V1,V2,V3]), 1.)
        for i in range(len(ls_pts[0])):
            #r_azi = (rank*ParamP[nump]['phyllotaxy'])/180.*3.14#radians + ajouter l'azi random de l'axe?
            pt = RotateAxis (ls_pts[0][i], r_azi, 0)#rotation a faire
            ls_pts[0][i] = pt + array([X0,Y0,Z0]) #translation
    
    #Hmax
    if nf > 3 or surF >= 0.001:#10cm2
        for i in range(len(ls_pts)):
            if ls_pts[0][i][2]>invar['Hplante'][nump]:
                invar['Hplante'][nump] = ls_pts[0][i][2]
    else:
        if Z0>invar['Hplante'][nump]:
            invar['Hplante'][nump] = Z0
    
    if Z0>Hcut and isTTcut==True:
        invar['Hplante'][nump]=Hcut
    
    
    #sen participe a surface et LAI (interception) mais pas au PARa (absorption)
    if age> ParamP[nump]['spanMrt'] or tt_omb> ParamP[nump]['ombF_Ttresh']+ParamP[nump]['spanMrt']-ParamP[nump]['spanSen'] :
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        invar['dMSenFeuil'][nump] += mfeuilmorte
        produce *
    else:
        newage = age+STEPS
        
        #calcul des PARif, PARaf et complete
        if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee
            ls_vox, ls_strate, ls_PARif, ls_PARaF = [], [], [], []
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                #print ls_pts[i], array([X0,Y0,Z0])
                vox = riri.WhichVoxel(ls_pts[0][i], origin_grid, na, dxyz)
                ls_vox.append(vox)
                ls_strate.append(vox[2])
                ls_PARif.append(res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX )
                
                # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (
                sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
                if sVOX>0.:
                    ls_PARaF.append(res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surf_elementaire/sVOX *3600.*24/1000000.)
                else: #feuille dans voxel sans surface?
                    ls_PARaF.append( res_trans[vox[2]][vox[1]][vox[0]] * surf_elementaire * 3600.*24/1000000.)
            
            PARif = max(ls_PARif)#min ou moy?
            strate = max(ls_strate)#?? pas correct
            PARaF = sum(ls_PARaF)
        else:
            vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
            strate = vox[2] #starte z
            PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise 
            
            # -> y a des nan iexpliques?? -> pas de surface ds ce voxel au coup d'avant? -> feuille a change de vosel?? (elongation noeud?)
            sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]#surface folaire dans le voxel
            if sVOX>0.:
                PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
            else: #feuille dans voxel sans surface?
                PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        
        
        I_I0 = PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        
        ###ajout dans ls_organs et profil I_I0: 1 seule feuille (tient pas compte des feuilles multiples)
        ranklong = rank+rankp if ordre==2 else rank
        ranklong = min(ranklong, len(ParamP[nump]['profilLeafI_l'])-1)#au cas ou profil trop long
        cor_ordre=ParamP[nump]['ratioII'] if ordre==2 else 1.
        Longueur = ParamP[nump]['profilLeafI_l'][ranklong]*l*cor_ordre
        Largeur = ParamP[nump]['profilLeafI_larg'][ranklong]*l*cor_ordre
        
        lsOrgans.append([TT,'Lf',nump,nsh,rank,rankp,strate,surF,PARaF,statut,newage,ordre,l,Longueur,DOY,cutNB,Largeur]) #decalage de un step pour l en exp
        invar['SurfPlante'][nump].append(surF)
        I_I0profilLfPlant[nump][classI_I0] += surF
        
        
        #profil vertical de surface
        if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee
            surf_elementaire = surF / float(len(ls_pts[0]))
            for i in range(len(ls_pts[0])):
                strate = ls_strate[i]
                SurfprofilPlant[nump][strate] += surf_elementaire
        else:
            SurfprofilPlant[nump][strate] += surF
        
        
        if age> ParamP[nump]['spanSen'] : 
            if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb,'sen',ordre)
        elif tt_omb> ParamP[nump]['ombF_Ttresh']:
            #print "ombre!"
            if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                surf_elementaire = surF / float(len(ls_pts[0]))
                for i in range(len(ls_pts[0])):
                    vox = ls_vox[i]
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
            else:
                m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF 
            
            invar['PARiPlante'][nump].append(PARaF)
            produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb+STEPS,'sen',ordre)
        else:
            invar['PARaPlante'][nump].append(PARaF)
            invar['PARiPlante'][nump].append(PARaF)
            adTTomb = STEPS if PARif <= ParamP[nump]['ombF_Ltresh'] else 0
            
            if statut == 'exp':
                pot = expansion(age+STEPS, ParamP[nump]['aF'], ParamP[nump]['delaiF']) - expansion(age, ParamP[nump]['aF'], ParamP[nump]['delaiF'])
                dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
                newsurF = calc_surF(nump, rank, rankp, ordre, l+dl)
                
                if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                    surf_elementaire = newsurF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
                
                stat = 'mat'if pot<0.005 and age>ParamP[nump]['delaiF'] else 'exp'
                produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l+dl,tt_omb+adTTomb,stat,ordre)
            elif statut == 'mat':
                if nf > 3 or surF >= 0.001:#10cm2#  #feuilles multifoliee 
                    surf_elementaire = surF / float(len(ls_pts[0]))
                    for i in range(len(ls_pts[0])):
                        vox = ls_vox[i]
                        m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surf_elementaire
                else:
                    m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
                
                produce GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump,nsh,newage,rank,rankp,l,tt_omb+adTTomb,statut,ordre)


Stp(nump,azi,l, statut) > Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    STEPS = invar['dTT'][nump]
    
    if ParamP[nump]['gotStip']== 1. and age < ParamP[nump]['spanMrt']:#presence stipules
        #strate = max(0, int(ceil((Z0+0.00001)/dz))-1)
        vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
        strate = vox[2] #starte z
        
        surF = calc_surS(nump, rank, rankp, ordre, l) #m2
        PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
        I_I0 =  PARif/meteo_j['I0']
        classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
        
        sVOX = m_lais[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]]
        if sVOX>0.:
            PARaF = res_abs_i[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] * surF/sVOX *3600.*24/1000000.
        else:
            PARaF = res_trans[vox[2]][vox[1]][vox[0]] * surF * 3600.*24/1000000.
        #print PARaF, PARaF_bis, sVOX#
        
        lsOrgans.append([TT,'Stp',nump,nsh2,rank,rankp,strate,surF,PARaF,statut,age2+STEPS,ordre,l,'NA',DOY,cutNB,'NA'])
        SurfprofilPlant[nump][strate] += surF #suppose mis dans meme strate que feuille
        I_I0profilLfPlant[nump][classI_I0] += surF
        invar['SurfPlante'][nump].append(surF)
        invar['PARiPlante'][nump].append(PARaF)
        invar['PARaPlante'][nump].append(PARaF)
        
        
        if statut == 'exp':
            pot = expansion(age2+STEPS, ParamP[nump]['aS'], ParamP[nump]['delaiS']) - expansion(age2, ParamP[nump]['aS'], ParamP[nump]['delaiS'])
            dl = pot*ls_ftswStress['WaterTreshExpSurf'][nump]*ls_NNIStress['NTreshExpSurf'][nump]
            newsurF = calc_surS(nump, rank, rankp, ordre, l+dl)
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += newsurF
            
            if pot<0.005 and age>ParamP[nump]['delaiS'] :
                produce Stp(nump,azi,l+dl, 'mat')
            else :
                produce Stp(nump,azi,l+dl, 'exp')
        else : #reste en 'mat'
            m_lais_construct[ParamP[nump]['id_grid']][vox[2]][vox[1]][vox[0]] += surF
            produce Stp(nump,azi,l, 'mat')
    elif ParamP[nump]['gotStip']== 1. and age >= ParamP[nump]['spanMrt']: # stipule mort ou 'spanMrt' -> retire de la chaine et met ddans residus feuille
        surF = calc_surS(nump, rank, rankp, ordre, l)#m2      
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mfeuilmorte = surF*10000/ParamP[nump]['SLAmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mfeuilmorte
        produce *
    else: 
        produce *


Pet(nump,nsh,age, phyllotax, l, statut) > GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    global ls_ftswStress
    STEPS = invar['dTT'][nump]
    
    newage = age+STEPS
    lpet = calc_Lpet(nump, rank, rankp, ordre, l)
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.
    I_I0profilPetPlant[nump][classI_I0] += lpet
    #photomorphogenese
    
    RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_pet'][0]*RFR)+ParamP[nump]['photomorphRFR_pet'][1]
    
    durjour = DayLength (latitude,DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect=trilineaire(PAReff,ParamP[nump]['photomorphPAR_pet'][0],ParamP[nump]['photomorphPAR_pet'][1],ParamP[nump]['photomorphPAR_pet'][2],ParamP[nump]['photomorphPAR_pet'][3])
    photomorph=RFR_effect*PAR_effect#1.
    invar['phmgPet'][nump].append(photomorph)
    invar['phmgPet_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'Pet',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre,l,lpet,DOY,cutNB,'NA'])#decalage de un step pour l avec age en exp ou mort
    
    if age> ParamP[nump]['spanMrt'] or nsh in invar['lsApexMort'][nump]:#mort du module
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        mpetmort = lpet*100/ParamP[nump]['SPLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4][voxsol[2]][voxsol[1]][voxsol[0]] += mpetmort
        invar['dMSenTige'][nump] += mpetmort#g
        produce *
    
    elif statut == 'exp':
        pot = expansion(newage, ParamP[nump]['aP'], ParamP[nump]['delaiP']) - expansion(age, ParamP[nump]['aP'], ParamP[nump]['delaiP'])
        dl = pot * ls_ftswStress['WaterTreshExpSurf'][nump] *ls_NNIStress['NTreshExpSurf'][nump]* photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiP']:#passe en 'mature'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, 'mat')
        else: #reste en 'exp'
            produce Pet(nump,nsh,newage, phyllotax, l+dl, statut)
    else:#reste en 'mat'
        produce Pet(nump,nsh,age+STEPS, phyllotax,l,statut)


GetPos(X0,Y0,Z0)In(nump,nsh,age,rank,rankp, l, statut,ordre):
    global ls_ftswStress, lsOrgans      
    STEPS = invar['dTT'][nump]
    
    newage = age+STEPS
    lent = calc_Lent(nump, rank, nsh, ordre, l)#cm
    
    vox = riri.WhichVoxel(array([X0,Y0,Z0]), origin_grid, na, dxyz)
    PARif = res_trans[vox[2]][vox[1]][vox[0]]/ surf_refVOX #W.m-2 -> utilise
    I_I0 =  PARif/meteo_j['I0']
    classI_I0 = min(int(I_I0/deltaI_I0) , nbI_I0-1) #pour gerer cas du I_I0=1.    
    
    RFR=RFR=res_rfr[vox[2]][vox[1]][vox[0]]
    RFR_effect=(ParamP[nump]['photomorphRFR_int'][0]*RFR)+ParamP[nump]['photomorphRFR_int'][1]
    
    durjour = DayLength (latitude,DecliSun (DOY % 365))
    PAReff = PARif * 24./durjour #courbe de reponse au PAR calle sur moyenne sur photoperiode
    PAR_effect=trilineaire(PAReff,ParamP[nump]['photomorphPAR_int'][0],ParamP[nump]['photomorphPAR_int'][1],ParamP[nump]['photomorphPAR_int'][2],ParamP[nump]['photomorphPAR_int'][3])
    photomorph=RFR_effect*PAR_effect #1.
    invar['phmgEntr'][nump].append(photomorph)
    invar['phmgEntr_m'][nump].append(photomorph)
    
    lsOrgans.append([TT,'In',nump,nsh,rank,rankp,'NA','NA','NA',statut,newage,ordre, l,lent,DOY,cutNB,'NA']) #decalage de un step pour l et age en exp!
    invar['NBphyto'][nump] += 1 #comptage du phytomere 
    
    if nsh in invar['lsApexMort'][nump]: #Meurt si tige meurt meurt
        voxsol = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        minmort = lent*100/ParamP[nump]['SNLmin'] #g
        groupe_resid = int(ParamP[nump]['groupe_resid'])
        ls_mat_res[groupe_resid*4+1][voxsol[2]][voxsol[1]][voxsol[0]] += minmort
        invar['dMSenTige'][nump] += minmort
        produce *
    elif statut == 'exp':
        pot = expansion(age+STEPS, ParamP[nump]['aE'], ParamP[nump]['delaiE']) - expansion(age, ParamP[nump]['aE'], ParamP[nump]['delaiE'])
        dl = pot * ls_ftswStress['WaterTreshExpSurf'][nump] *ls_NNIStress['NTreshExpSurf'][nump]* photomorph
        
        if pot<0.005 and age>ParamP[nump]['delaiE']:#passe en 'mature'
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp, l+dl, 'mat',ordre)
        else: #reste en 'exp'
            produce GetPos(X0,Y0,Z0)In(nump,nsh,newage,rank,rankp, l+dl, statut,ordre)
    else: #reste en 'mat'
        produce GetPos(X0,Y0,Z0)In(nump,nsh,age+STEPS,rank,rankp, l, statut,ordre)


D(nump,nsh, statut,age,posi,parent):
    STEPS = invar['dTT'][nump]
    invar['NBD1'][nump]+=1
    nbExp_Prev = outvar['NBBexp'][-1][0][nump+2]+1 #nb bourgeons type exp juste avant
    
    
    if parent in invar['lsApexMort'][nump]: #Meurt si parent meurt
        #invar['lsApexMort'][nump].remove(parent) #l'enleve pas de la liste car sinon pas visible pour autres organes
        invar['countShExp'][nump] -= 1
        produce *
    #elif nbExp_Prev<=ParamP[nump]['NBexp'] and invar['countShExp'][nump]< ParamP[nump]['nshoots']-1:#cree bourgeon si NBB exp pas atteint
    #    print 'vrai'
    #    outvar['NBBexp'][-1][0][nump+2] +=1
    #    invar['NBBexp'][nump] +=1
    #    newage = age%ParamP[nump]['phyllochron']+STEPS
    #    new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#0
    #    newazi = random.uniform(0.,360.)
    #    produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'exp')
    elif not parent in invar['lsAPrev'][nump] :#and statut==0: #sort de dormance si tige parente coupee
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        #produce D(nump,nsh,1,newage,posi,parent)
    #elif statut ==1:#pas d'apres produit un nouvel axe
        NIparent = max(invar_sc['sh']['MaxNI'][str(nump)+'_'+str(parent)])
        deltaBud = MaturBud(ParamP[nump]['delaiMaturBud'], NIparent)
        
        #newage = age%ParamP[nump]['phyllochron']+STEPS
        newage = deltaBud*ParamP[nump]['phyllochron']# + STEPS  #+age%ParamP[nump]['phyllochron'] #rajoute pas le steps car compare a zero apres
        new_nrhiz = binomial(ParamP[nump]['DistLRhiz'][0], ParamP[nump]['DistLRhiz'][1])#2#0
        newazi = random.uniform(0.,360.)
        
        #print 'D', nsh, parent, NIparent, deltaBud, newage
        
        produce @M(posi[0],posi[1],posi[2])SetHead()/(newazi)&(90)B(nump, nsh, newage, posi, new_nrhiz,newazi, 0,'regular') #un bourgeon ave un nsh qui ne rajoute pas de nvelle tige
    else:
        produce D(nump,nsh, statut,age+STEPS,posi,parent)


D2(nump, nsh, age, rankp, phyllotax,shoottype):
    STEPS = invar['dTT'][nump]
    
    if nsh in invar['lsApexMort'][nump] or shoottype=="primary": #Meurt si tige porteuse meurt #disparait si il y a aussi un D avec lequel D2 fait "double emploi"
        produce *
    elif age <= ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII']:
        #print("agetropjeune",age)
        produce D2(nump,nsh,age+STEPS,rankp, phyllotax,shoottype)
    elif int(ParamP[nump]['ActiveBranch'])==True:
        init_age = age-(ParamP[nump]['delai_deb']-ParamP[nump]['phyllochronII'])
        #print("agedepasse",init_age, age)
        elv0 = 45
        if rankp%2==0:
            produce +(90-elv0)GetPos(0,0,0)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)
        else:
            produce -(90-elv0)GetPos(0,0,0)A2(nump, nsh, 1, init_age, 0, 0, rankp, phyllotax+30)

RA(nump, nsh, age, rankp, agecum, moduloH):
    STEPSsol = invar['dTTsol'][nump]
    
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    # quelle prof max de sol si il y a un obstarac?
    if S.obstarac is None or type(S.obstarac != type(array([0.]))):
        prof_obst = prof_sol_max
    else:
        #dans quel voxl de sol est la plante
        vox = riri.WhichVoxel(array(carto[nump]), [0.,0.,0.], [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], [S.dxyz[0][0]*100., S.dxyz[1][0]*100., S.dxyz[2][0]*100.])  
        prof_obst =  -S.obstarac[vox[0], vox[1]]*100.
        #print 'sol depth', prof_sol_max, vox, S.obstarac[vox[0], vox[1]]#, na, [len(lims_sol[0])-1, len(lims_sol[1])-1, len(lims_sol[2])-1], vox
    
    
    if moduloH>invar['RDepth'][nump]:
        invar['RDepth'][nump]=moduloH
    
    #ajout d'un cyclindre dans syst racinaire pour racine primaire/pivot
    ls_systrac[nump].append([carto[nump][0],carto[nump][1],0.,0.01,max(moduloH,0.01)])
    
    #ajout dans ls_organs
    lsOrgans.append([TT,'Piv',nump,nsh,rankp,0,'NA','NA','NA','NA',agecum+STEPSsol,1,0,moduloH,DOY,cutNB,'NA'])
    
    
    #calcul ratio QD instantane
    if(agecum<ParamP[nump]['DurGraine']):
        ratio=1.
    else:
        ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #seuil pour emission d'un nouveau root segment
    tresh=ParamP[nump]['Relongation_duration0']/max(0.0001, ratio)
    #print moduloH, moduloH%dz_sol, prof_sol_max
    if age>tresh and moduloH%dz_sol==0. and moduloH<min([prof_sol_max, prof_obst]):
        #print moduloH, dz_sol, moduloH%dz_sol, int(moduloH/dz_sol)
        produce RLB(nump,nsh,0,rankp, int(moduloH/dz_sol))RS(nump,nsh, rankp,moduloH)RA(nump,nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol, moduloH+ParamP[nump]['LRS'])
    elif age>tresh and moduloH<min([prof_sol_max, prof_obst]):
        produce RS(nump, nsh, rankp, moduloH)RA(nump, nsh, age%tresh+STEPSsol, rankp, agecum+STEPSsol,moduloH+ParamP[nump]['LRS'])
    else:
        produce RA(nump,nsh, age+STEPSsol, rankp, agecum+STEPSsol,moduloH)


RLB(nump,nsh,age,rankp, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratio = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax)
    
    tresh=ParamP[nump]['delai_RLAP']/max(0.0001, ratio)
    
    if age>tresh:
        produce [GetPos(0.,0.,0.)RLAP(nump,nsh,age%tresh+STEPSsol, rankp, 0.01, Horiz)]
    else:
        produce RLB(nump,nsh,age+STEPSsol,rankp, Horiz)


GetPos(X0,Y0,Z0)RLAP(nump,nsh,age,rankp,l, Horiz):
    STEPSsol = invar['dTTsol'][nump]
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    
    #calcul ratio QD instantane
    ratioC = rt.get_QDCmoy(invar_sc['ax']['QDCRac'], idax) 
    
    #stressHydrique
    stressH = FTSW_resp(mean(S.ftsw_t[Horiz,:,:]), ParamP[nump]['WaterTreshElRoots'])
    
    #ajout pondere pour calcul de stress H racinaire global
    invar_sc['ax']['StressHRac'] = add_dic({idax:stressH*l}, invar_sc['ax']['StressHRac'])
    invar_sc['ax']['PonderStressHRac'] = add_dic({idax:l}, invar_sc['ax']['PonderStressHRac'])
    
    #print idax, stressH, invar_sc['ax']['StressHRac'][idax] / invar_sc['ax']['PonderStressHRac'][idax]
    
    dl = (STEPSsol/ParamP[nump]['Relongation_durationII'])*ratioC*stressH
    #print dl, invar_sc['ax']['QDCRac'], invar_sc['ax']['AgePiv']#invar_sc['ax']['OfrCRac']#ratioC, stressH
    # nbplantes, invar_sc['ax']['AgePiv'], invar_sc['plt']['PARaF'], invar_sc['ax']['PARaF']
    #RprospectProfil[nump][Horiz] = l+dl
    
    #calculation new enveloppe
    id = r.idLong(l, ParamP[nump]['profilRoot'])
    larg = ParamP[nump]['profilRoot']['y'][id]
    long = min(max(dz_sol ,ParamP[nump]['profilRoot']['x'][id]), prof_sol_max+Z0)
    ls_systrac[nump].append([X0,Y0,-Z0,larg,long])
    
    if age<=(ParamP[nump]['GDs1']+ParamP[nump]['GDs2'])/2:#durre expansion enveloppe secondaire determinee par Dmax et D2 -> devrait utiliser varD pour laterales les plus larges
        produce GetPos(X0,Y0,Z0)RLAP(nump,nsh,age+STEPSsol,rankp, l+dl, Horiz)
    else:
        produce GetPos(X0,Y0,Z0)RLAP(nump,nsh,age+STEPSsol,rankp, l, Horiz)
    #rq: croissance indeterminee! -> tient pas compte de GDs



[GetPos(X0,Y0,Z0)RB(nump,nsh,age,rankp,statut)]:
    global S
    STEPSsol = invar['dTTsol'][nump]
    
    Horiz=0
    if Z0 > ParamP[nump]['HeightTreshAdvRoots']: #supprime bud si au dessus d'une hauteur seuil
        produce *
    elif age>ParamP[nump]['delai_AdvRoots'] and statut==0:
        pb = random.uniform(0.,1.)
        if pb<ParamP[nump]['ProbaMaxAdvRoots'] :
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,1)] #statut
        else: #supprime bud si sous proba seuil
            produce *
    elif statut==1 :#en attente bloque par stress hydrique
        if age>ParamP[nump]['delai_AdvRoots']+ParamP[nump]['fenetre_AdvRoots']:
            produce *
        else:
            if mean(S.ftsw_t[Horiz,:,:]) > ParamP[nump]['WaterTreshAdvRoots']:
                produce [;(0)SetHead(0,0,-1, -1,0,0)RA(nump,nsh,-1,rankp,0,0)]
            else:
                produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,statut)]
    else:#statut 0 en attente du delai de debourrement 'delai_AdvRoots'
        produce [GetPos(X0,Y0,Z0)RB(nump,nsh,age+STEPSsol,rankp,statut)]

[] --> * #pour nettoyer les bracket des D() morts


sol(sol_obj, nbcol):
    if nbcol>0:
        nproduce [solxy(sol_obj, nbcol-1)]sol(sol_obj, nbcol-1)
    else:
        produce *

attente(n):
    global S, discret_solXY
    if n>0:
        produce attente(n-1)
    else:
        produce pattern(0)sol(S, discret_solXY[1])


interpretation:
SHP(nump,azi, elv0,posi,nbp,par):
    if elv0 < ParamP[nump]['elvtresh'] and par>=meteo_j['I0']*ParamP[nump]['par_tresh']:#pour moduler incli0 par longueur/incli en plante isolee
        Lsh = ParamP[nump]['Len']*nbp
        Hsh = Lsh*sin(elv0*pi/180.)
        corr_elv = max(0,(ParamP[nump]['Lmaxeffet']-Hsh))/ParamP[nump]['Lmaxeffet'] 
    elif elv0 < 60 and par<meteo_j['I0']*ParamP[nump]['par_tresh']: #pour moduler incli competition forte/ a revoir au niveau de la loi de ditrib ou de elasticite
        corr_elv =1.#1.3
    else:
        corr_elv =1.
        
    produce &(-elv0*corr_elv)


In(nump,nsh,age,rank,rankp, l, statut,ordre):
    lent = calc_Lent(nump, rank, nsh, ordre, l)*100. #cm
    if ordre==2:
        color=2
    else:
        color=3
    if ordre==1 and nsh==0:
        color=2
    
    if visu_shoot==1:
        #produce ;(2)@Tp([0,0,1])Ts(lent*ParamP[nump]['elasticity'])F(lent,0.3)
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))F(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs
    else:
        produce ;(color)@Tp([0,0,1])@Ts(min(1,lent*ParamP[nump]['elasticity']))f(lent,0.3)# modif lucas : min() car avait de drole de comportement sans ca a certaines valeurs

A(nump,nsh,statut,age, duromb, rank, phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(3)Sphere(0.4)
        else:
            produce ;(4)Sphere(0.4)

A2(nump, nsh, statut, age, duromb,rank, rankp, phyllotax):
    if visu_shoot==1:
        if statut ==1:
            produce ;(1)Sphere(0.3)
        else:
            produce ;(4)Sphere(0.3)


#D(nump,statut,posi) --> @M(posi[0],posi[1],posi[2])#;(1)Sphere(0.2)#les voit pas


Pet(nump, nsh, age, azi,l1, statut1) > GetPos(X0,Y0,Z0)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    lpet = calc_Lpet(nump, rank, rankp, ordre, l1)*100.#cm
    IncPet = ParamP[nump]['IncPet']
    if visu_shoot==1:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)
        #produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet);(2)F(0.00001,0.1)F(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)  
    else:
        produce SetHead(0,0,1, 1,0,0)/(azi%360)Up(IncPet)_(0.1)f(lpet,0.1)SetHead(0,0,1, 1,0,0)/(azi%360-90)


Lf(nump, nsh, age, rank, rankp, l, tt_omb, statut,ordre):
    if visu_shoot==1:
        cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
        rk = rank+rankp if ordre==2 else rank
        rk = min(rk, len(ParamP[nump]['profilLeafI_l'])-1) #au cas ou profil pas assez long
        Long  = ParamP[nump]['profilLeafI_l'][rk]*l*cor_ordre
        Larg = ParamP[nump]['profilLeafI_larg'][rk]*l*cor_ordre
        nf = ParamP[nump]['profilLeafI_nfol'][rk]
        if statut == 'exp' or statut == 'mat':
            col=2#2
        elif statut == 'sen':
            col = 1
        
        if ordre ==2:
            col = 3#2
            
        #insere pour mixtures
        if ParamP[nump]['type']==1:
            col=2
        else:
            col=6
        
        #geom = leg_leaf(Long, Larg, gamma=ParamP[nump]['gammaFeuil'])
        geom = leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'])
        #print leg_leaf_lucas(Long, Larg, gamma=ParamP[nump]['gammaFeuil'], nfol=nf, anginit=ParamP[nump]['IncPet'], geom=False)
        produce ;(col)@g(geom)


Stp(nump, azi,l, statut)> Pet(nump1, nsh, age, azi1, l1, statut1)GetPos(X0_,Y0_,Z0_)GetUp(V1,V2,V3)Lf(nump2,nsh2,age2,rank,rankp,l2,tt_omb,statut2,ordre):
    if visu_shoot==1:
        if ParamP[nump]['gotStip']== 1.:
            cor_ordre = ParamP[nump]['ratioII'] if ordre==2 else 1.
            rk = rank+rankp if ordre==2 else rank
            rk = min(rk, len(ParamP[nump]['profilStipI_l'])-1) #au cas ou profil pas assez long
            Long = l*ParamP[nump]['profilStipI_l'][rk]*cor_ordre
            Larg = l*ParamP[nump]['profilStipI_larg'][rk]*cor_ordre
            stip = geomstip(Long, Larg,alpha=90,gamma=ParamP[nump]['gammaFeuil'])
            col = 5#0#2#
            produce SetHead(0,0,1, 1,0,0)/(azi%360-90);(col)@g(stip)
            #y a des implicites pour les angles


Coll(posi) --> @M(posi[0],posi[1],posi[2])[;(0)SetHead(0,0,-1, -1,0,0) #! contient ouverture de [ du systeme racinaire

RA(nump,nsh,age, rankp,agecum,moduloH): 
    if visu_root==1:
        produce ;(3)Sphere(0.4)

RS(nump, nsh, rankp, moduloH):
    #diampiv = max(0.1 ,invar['DiampivMax'][nump]*(1-moduloH/ParamP[nump]['ZPivot_min'])) 
    idax = str(nump)+'_'+str(nsh)+'_'+str(rankp)
    diampiv = max(0.1 ,invar_sc['ax']['DiampivMax'][idax]*(1-moduloH/ParamP[nump]['ZPivot_min']))
    if visu_root==1:
        produce ;(1)_(diampiv)F(ParamP[nump]['LRS'])
    else:
        produce ;(1)_(diampiv)f(ParamP[nump]['LRS'])

RLB(nump,nsh,age,rankp, Horiz): 
    if visu_root==1:
        produce ;(0)Sphere(0.4)

RLAP(nump,nsh,age,rankp, l, Horiz): 
    id = r.idLong(l, ParamP[nump]['profilRoot'])
    #print id, l
    larg = ParamP[nump]['profilRoot']['y'][id]
    long = max(dz_sol ,ParamP[nump]['profilRoot']['x'][id])
    if visu_root==1:
        produce ;(0)_(larg)F(long)
        #produce ;(0)_(l)F(dz_sol)
    else:
        produce ;(0)_(larg)f(long)

solxy(sol_obj, idcol):
    if visu_sol == 1:
        global dz_sol, ncouches_sol, discret_solXY
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        Nmin_xy = mean(sol_obj.m_NO3, axis=1)#mean(sol_obj.m_NO3+sol_obj.m_NH4)/(sol_obj.m_soil_vol*sol_obj.m_DA)*1000, axis=1)
        norm_Nmin_xy = Nmin_xy/Nmin_xy.max()
        norm_Nmin_xy = norm_Nmin_xy[:,idcol]
        
        ftsw_xy = mean(sol_obj.ftsw_t, axis=1)[:,idcol]
        nbcol = discret_solXY[1]
        larg_box = 30.
        
        #print norm_Nmin_xy #ftsw_xy
        for i in range(ncouches_sol):
            z = -i*dz_sol
            values = ftsw_xy#norm_Nmin_xy#   A changer pour voir variable de sortie souhaitee
            
            #ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            ftsw = max(0, values[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            #nproduce ;(col)@M(-50,0,z-dz_sol)@g(Box(1,30,dz_sol))
            nproduce ;(col)@M(-50,float(idcol)*2*larg_box/float(nbcol),z-dz_sol)@g(Box(1,larg_box/float(nbcol),dz_sol))



sol(sol_obj, nbcol):
    if visu_sol == 1:
        #l'affiche au premier step pour bien definir champs de la camera
        global dz_sol, ncouches_sol
        #print mean(sol_obj.HRp(), axis=1)[:,0]#mean(mean(sol_obj.HRp(), axis=0), axis=0)
        for i in range(ncouches_sol):
            z = -i*dz_sol
            ftsw = max(0., mean(sol_obj.ftsw_t[i,:,:]))
            #ftsw = max(0, ftsw_xy[i])
            col = 16 + int(ceil((1-ftsw)/0.1))
            nproduce ;(col)@M(-53,0,z-dz_sol)@g(Box(1,30,dz_sol))
            #nproduce ;(col)@M(-50,float(idcol)*30./float(nbcol),z-dz_sol)@g(Box(1,30./float(nbcol),dz_sol))




#aer:
#    global res_abs_i, dxyz, Hmaxcouv, Lsol, largsol
#    if(getIterationNb()>2):
#        for ty in range(5,20):
#          for tx in range(5,20):
#            for i in range(50):
#              z = 50*dxyz[2]-(i*dxyz[2])
#              x = tx*(dxyz[0])
#              y= ty*(dxyz[1])
#              xx0=-(dxyz[0]*Lsol/2)+dxyz[0]/2
#              yy0=-(dxyz[1]*largsol/2)+dxyz[1]/2
#              ftsw = max(0., res_abs_i[0][i][tx][ty])
#              col = 18 - int(ceil((ftsw)/0.025))
#              nproduce ;(col)@M(yy0+y,xx0+x,z+dxyz[0])@g(Box(dxyz[1]/2,1,dxyz[2]))


pattern(0):
    if visu_sol == 1:
        produce ;(1)@M((pattern8[1][0]+pattern8[0][0])/2.,(pattern8[1][1]+pattern8[0][1])/2.,0)@g(Box((pattern8[1][0]-pattern8[0][0])/2.,(pattern8[1][1]-pattern8[0][1])/2.,0.1))


attente(n):
    if visu_sol == 1:
        produce ;(1)@M(-53,0,0)@g(Box(1,30,150)) #pour creer fenetre de taille correcte


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_0 = pgl.Material("Color_0" , ambient = (221,221,221) , diffuse = 0.723982 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_4 = pgl.Material("Color_4" , ambient = (10,14,241) , diffuse = 0.746888 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_16 = pgl.Material("Color_16" , ambient = (0,0,234) , diffuse = 0.641026 , transparency = 0.5 , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_17 = pgl.Material("Color_17" , ambient = (63,63,239) , diffuse = 0.573906 , transparency = 0.4825 , )
	Color_17.name = "Color_17"
	context.turtle.setMaterial(17,Color_17)
	Color_18 = pgl.Material("Color_18" , ambient = (127,127,244) , diffuse = 0.506787 , transparency = 0.465 , )
	Color_18.name = "Color_18"
	context.turtle.setMaterial(18,Color_18)
	Color_19 = pgl.Material("Color_19" , ambient = (191,191,249) , diffuse = 0.439668 , transparency = 0.4475 , )
	Color_19.name = "Color_19"
	context.turtle.setMaterial(19,Color_19)
	Color_20 = pgl.Material("Color_20" , ambient = (255,255,255) , diffuse = 0.372549 , transparency = 0.43 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	Color_21 = pgl.Material("Color_21" , ambient = (248,212,212) , diffuse = 0.433345 , transparency = 0.416667 , )
	Color_21.name = "Color_21"
	context.turtle.setMaterial(21,Color_21)
	Color_22 = pgl.Material("Color_22" , ambient = (242,170,170) , diffuse = 0.494142 , transparency = 0.403333 , )
	Color_22.name = "Color_22"
	context.turtle.setMaterial(22,Color_22)
	Color_23 = pgl.Material("Color_23" , ambient = (236,127,127) , diffuse = 0.554938 , transparency = 0.39 , )
	Color_23.name = "Color_23"
	context.turtle.setMaterial(23,Color_23)
	Color_24 = pgl.Material("Color_24" , ambient = (229,85,85) , diffuse = 0.615734 , transparency = 0.376667 , )
	Color_24.name = "Color_24"
	context.turtle.setMaterial(24,Color_24)
	Color_25 = pgl.Material("Color_25" , ambient = (223,42,42) , diffuse = 0.676531 , transparency = 0.363333 , )
	Color_25.name = "Color_25"
	context.turtle.setMaterial(25,Color_25)
	Color_26 = pgl.Material("Color_26" , ambient = (217,0,0) , diffuse = 0.737327 , transparency = 0.35 , )
	Color_26.name = "Color_26"
	context.turtle.setMaterial(26,Color_26)
